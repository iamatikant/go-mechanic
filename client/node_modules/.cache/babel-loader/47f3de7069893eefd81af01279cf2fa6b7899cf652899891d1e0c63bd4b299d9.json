{"ast":null,"code":"import { useState, useLayoutEffect, useCallback } from 'react';\nimport { windowIsAvailable, debounce } from '../utils';\nimport useChToPxConversionFactor from './useChToPxConversionFactor';\nimport useTheme from './useTheme';\n// We should be able to safely capture once as the computed root font size is unlikely to change during normal runtime.\nconst rootFontSize = window.getComputedStyle(document.documentElement).fontSize;\n/**\n * @example const breakpointActive = useBreakpoint(breakpoint);\n * @param breakpoint The string indicator for the breakpoint that should be checked for validity.\n * @param options\n * @returns breakpointActive:: A boolean indicating if the given breakpoint is active or not. If false, the breakpoint is too big for the screen size.\n */\nconst useBreakpoint = function (breakpoint) {\n  let {\n    breakpointRef,\n    defaultValue = false,\n    themeProp = 'breakpoints'\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    base: {\n      breakpoints,\n      'content-width': contentWidth\n    }\n  } = useTheme();\n  const breakpointVal = themeProp === 'content-width' ? contentWidth[breakpoint] : breakpoints[breakpoint];\n  const [matches, setMatches] = useState(windowIsAvailable ? window.matchMedia(`(min-width: ${breakpointVal})`).matches : !!defaultValue);\n  const chToPxConversionFactor = useChToPxConversionFactor();\n  const onResize = useCallback(e => {\n    setMatches(e.matches);\n  }, []);\n  useLayoutEffect(() => {\n    // Breakpoint handling for contained elements\n    if (breakpointRef && breakpointRef.current) {\n      const observer = new ResizeObserver(entries => {\n        const matchesBreakpoint = entries.some(_ref => {\n          let {\n            target,\n            contentRect\n          } = _ref;\n          if (target !== breakpointRef.current) return;\n          const multiplier = themeProp === 'breakpoints' ? parseFloat(rootFontSize) : chToPxConversionFactor;\n          return contentRect.width >= parseFloat(breakpointVal) * multiplier;\n        });\n        setMatches(matchesBreakpoint);\n      });\n      observer.observe(breakpointRef.current);\n      return () => {\n        observer.disconnect();\n      };\n    }\n    // Breakpoint handling for viewport\n    if (windowIsAvailable) {\n      const mediaMatch = window.matchMedia(`(min-width: ${breakpointVal})`);\n      const mediaMatchAvailable = ('addEventListener' in mediaMatch);\n      const resizeHandler = debounce(() => {\n        setMatches(window.innerWidth >= parseInt(breakpointVal, 10));\n      }, 100);\n      // Need to check useMatchMedia in order to support unit testing\n      if (mediaMatchAvailable) {\n        mediaMatch.addEventListener('change', onResize);\n        setMatches(mediaMatch.matches);\n      } else {\n        window.addEventListener('resize', resizeHandler);\n        setMatches(window.innerWidth >= parseInt(breakpointVal, 10));\n      }\n      return () => {\n        // Need to check useMatchMedia in order to support unit testing\n        if (mediaMatchAvailable) mediaMatch.removeEventListener('change', onResize);else {\n          window.removeEventListener('resize', resizeHandler);\n        }\n      };\n    }\n  }, [breakpointRef?.current]);\n  return matches;\n};\nexport default useBreakpoint;","map":{"version":3,"names":["useState","useLayoutEffect","useCallback","windowIsAvailable","debounce","useChToPxConversionFactor","useTheme","rootFontSize","window","getComputedStyle","document","documentElement","fontSize","useBreakpoint","breakpoint","breakpointRef","defaultValue","themeProp","arguments","length","undefined","base","breakpoints","contentWidth","breakpointVal","matches","setMatches","matchMedia","chToPxConversionFactor","onResize","e","current","observer","ResizeObserver","entries","matchesBreakpoint","some","_ref","target","contentRect","multiplier","parseFloat","width","observe","disconnect","mediaMatch","mediaMatchAvailable","resizeHandler","innerWidth","parseInt","addEventListener","removeEventListener"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/@pega/cosmos-react-core/src/hooks/useBreakpoint.ts"],"sourcesContent":["import { useState, useLayoutEffect, useCallback, RefObject } from 'react';\n\nimport { windowIsAvailable, debounce } from '../utils';\n\nimport useChToPxConversionFactor from './useChToPxConversionFactor';\nimport useTheme from './useTheme';\n\n// We should be able to safely capture once as the computed root font size is unlikely to change during normal runtime.\nconst rootFontSize = window.getComputedStyle(document.documentElement).fontSize;\n\n/**\n * @example const breakpointActive = useBreakpoint(breakpoint);\n * @param breakpoint The string indicator for the breakpoint that should be checked for validity.\n * @param options\n * @returns breakpointActive:: A boolean indicating if the given breakpoint is active or not. If false, the breakpoint is too big for the screen size.\n */\nconst useBreakpoint = (\n  breakpoint: 'xs' | 'sm' | 'md' | 'lg' | 'xl',\n  {\n    breakpointRef,\n    defaultValue = false,\n    themeProp = 'breakpoints'\n  }: {\n    breakpointRef?: RefObject<Element> | undefined;\n    defaultValue?: boolean;\n    themeProp?: 'breakpoints' | 'content-width';\n  } = {}\n) => {\n  const {\n    base: { breakpoints, 'content-width': contentWidth }\n  } = useTheme();\n  const breakpointVal =\n    themeProp === 'content-width' ? contentWidth[breakpoint] : breakpoints[breakpoint];\n\n  const [matches, setMatches] = useState(\n    windowIsAvailable ? window.matchMedia(`(min-width: ${breakpointVal})`).matches : !!defaultValue\n  );\n\n  const chToPxConversionFactor = useChToPxConversionFactor();\n\n  const onResize = useCallback((e: MediaQueryListEvent) => {\n    setMatches(e.matches);\n  }, []);\n\n  useLayoutEffect(() => {\n    // Breakpoint handling for contained elements\n    if (breakpointRef && breakpointRef.current) {\n      const observer = new ResizeObserver(entries => {\n        const matchesBreakpoint = entries.some(({ target, contentRect }) => {\n          if (target !== breakpointRef.current) return;\n\n          const multiplier =\n            themeProp === 'breakpoints' ? parseFloat(rootFontSize) : chToPxConversionFactor;\n          return contentRect.width >= parseFloat(breakpointVal) * multiplier;\n        });\n\n        setMatches(matchesBreakpoint);\n      });\n\n      observer.observe(breakpointRef.current);\n\n      return () => {\n        observer.disconnect();\n      };\n    }\n\n    // Breakpoint handling for viewport\n    if (windowIsAvailable) {\n      const mediaMatch = window.matchMedia(`(min-width: ${breakpointVal})`);\n      const mediaMatchAvailable = 'addEventListener' in mediaMatch;\n      const resizeHandler = debounce(() => {\n        setMatches(window.innerWidth >= parseInt(breakpointVal, 10));\n      }, 100);\n\n      // Need to check useMatchMedia in order to support unit testing\n      if (mediaMatchAvailable) {\n        mediaMatch.addEventListener('change', onResize);\n        setMatches(mediaMatch.matches);\n      } else {\n        window.addEventListener('resize', resizeHandler);\n        setMatches(window.innerWidth >= parseInt(breakpointVal, 10));\n      }\n\n      return () => {\n        // Need to check useMatchMedia in order to support unit testing\n        if (mediaMatchAvailable) mediaMatch.removeEventListener('change', onResize);\n        else {\n          window.removeEventListener('resize', resizeHandler);\n        }\n      };\n    }\n  }, [breakpointRef?.current]);\n\n  return matches;\n};\n\nexport default useBreakpoint;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}