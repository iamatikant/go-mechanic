{"ast":null,"code":"import { getScrollbarWidth, testElForOverflow } from '../../utils';\nexport const sameWidth = Object.freeze({\n  name: 'sameWidth',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn(_ref) {\n    let {\n      state\n    } = _ref;\n    state.styles.popper.width = `${state.rects.reference.width}px`;\n  },\n  requires: ['computeStyles']\n});\nconst scrollbarSize = getScrollbarWidth();\nexport const placeAndContain = Object.freeze({\n  name: 'placeAndContain',\n  enabled: true,\n  phase: 'beforeWrite',\n  requires: ['computeStyles', 'offset'],\n  fn: _ref2 => {\n    let {\n      state\n    } = _ref2;\n    const [requestedPrimaryPlacement, requestedSecondaryPlacement] = state.placement.split('-');\n    const padding = {\n      top: 0,\n      bottom: 0,\n      right: 0,\n      left: 0\n    };\n    const preventOverflowPad = state.orderedModifiers.find(_ref3 => {\n      let {\n        name\n      } = _ref3;\n      return name === 'preventOverflow';\n    })?.options?.padding;\n    if (typeof preventOverflowPad === 'number') {\n      padding.top = preventOverflowPad;\n      padding.bottom = preventOverflowPad;\n      padding.right = preventOverflowPad;\n      padding.left = preventOverflowPad;\n    } else if (preventOverflowPad) {\n      padding.top = preventOverflowPad.top ?? padding.top;\n      padding.bottom = preventOverflowPad.bottom ?? padding.bottom;\n      padding.right = preventOverflowPad.right ?? padding.right;\n      padding.left = preventOverflowPad.left ?? padding.left;\n    }\n    const vw = document.documentElement.clientWidth;\n    const vh = document.documentElement.clientHeight;\n    const targetRect = state.rects.reference;\n    const targetRectXStart = targetRect.x;\n    const targetRectXEnd = targetRectXStart + targetRect.width;\n    const targetRectYStart = targetRect.y;\n    const targetRectYEnd = targetRectYStart + targetRect.height;\n    const targetXMid = (targetRectXStart + targetRectXEnd) / 2;\n    const targetYMid = (targetRectYStart + targetRectYEnd) / 2;\n    const targetIsInLeftHalfOfViewport = targetXMid < vw / 2;\n    const targetIsInTopHalfOfViewport = targetYMid < vh / 2;\n    const offsetFromTargetX = state.modifiersData.offset?.[state.placement]?.x ?? 0;\n    const offsetFromTargetY = state.modifiersData.offset?.[state.placement]?.y ?? 0;\n    let popoverMaxWidth = null;\n    let popoverMaxHeight = null;\n    const totalScrollableChildHeight = Array.from(state.elements.popper.children).reduce((sum, el) => {\n      if (el === state.elements.arrow) {\n        return sum;\n      }\n      if (testElForOverflow(el)[0]) {\n        return sum + el.scrollHeight + scrollbarSize;\n      }\n      return sum + el.scrollHeight;\n    }, 0);\n    const naturalPopoverHeight = Math.max(state.elements.popper.scrollHeight, totalScrollableChildHeight);\n    const naturalPopoverWidth = Math.max(state.elements.popper.scrollWidth, ...Array.from(state.elements.popper.children).map(el => {\n      if (el === state.elements.arrow) {\n        return -Infinity;\n      }\n      if (testElForOverflow(el)[1]) {\n        return el.scrollWidth + scrollbarSize;\n      }\n      return el.scrollWidth;\n    }));\n    let resolvedPlacement = requestedPrimaryPlacement;\n    if (requestedPrimaryPlacement === 'bottom') {\n      popoverMaxHeight = vh - targetRectYEnd - offsetFromTargetY - padding.bottom;\n      if (\n      // If the popover will overflow the viewport bottom\n      targetRectYEnd + offsetFromTargetY + naturalPopoverHeight > vh) {\n        // Choose the side with most allowance\n        resolvedPlacement = targetIsInTopHalfOfViewport ? 'bottom' : 'top';\n      }\n    } else if (requestedPrimaryPlacement === 'top') {\n      popoverMaxHeight = targetRectYStart + offsetFromTargetY - padding.top;\n      if (\n      // If the popover will overflow the viewport top\n      targetRectYStart + offsetFromTargetY - naturalPopoverHeight < 0) {\n        // Choose the side with most allowance\n        resolvedPlacement = targetIsInTopHalfOfViewport ? 'bottom' : 'top';\n      }\n    } else if (requestedPrimaryPlacement === 'left') {\n      popoverMaxWidth = targetRectXStart + offsetFromTargetX - padding.left;\n      if (\n      // If the popover will overflow the viewport left\n      targetRectXStart + offsetFromTargetX - naturalPopoverWidth < 0) {\n        // Choose the side with most allowance\n        resolvedPlacement = targetIsInLeftHalfOfViewport ? 'right' : 'left';\n      }\n    } else if (requestedPrimaryPlacement === 'right') {\n      popoverMaxWidth = vw - targetRectXEnd - offsetFromTargetX - padding.right;\n      if (\n      // If the popover will overflow the viewport right\n      targetRectXEnd + offsetFromTargetX + naturalPopoverWidth > vw) {\n        // Choose the side with most allowance\n        resolvedPlacement = targetIsInLeftHalfOfViewport ? 'right' : 'left';\n      }\n    }\n    if (resolvedPlacement === 'left' || resolvedPlacement === 'right') {\n      popoverMaxHeight = vh - padding.top - padding.bottom;\n    }\n    state.elements.popper.style.maxHeight = `${popoverMaxHeight}px`;\n    state.elements.popper.style.maxWidth = popoverMaxWidth !== null ? `${popoverMaxWidth}px` : '';\n    resolvedPlacement = `${resolvedPlacement}${requestedSecondaryPlacement ? `-${requestedSecondaryPlacement}` : ''}`;\n    if (state.placement !== resolvedPlacement) {\n      state.placement = resolvedPlacement;\n      state.reset = true;\n    }\n  }\n});","map":{"version":3,"names":["getScrollbarWidth","testElForOverflow","sameWidth","Object","freeze","name","enabled","phase","fn","_ref","state","styles","popper","width","rects","reference","requires","scrollbarSize","placeAndContain","_ref2","requestedPrimaryPlacement","requestedSecondaryPlacement","placement","split","padding","top","bottom","right","left","preventOverflowPad","orderedModifiers","find","_ref3","options","vw","document","documentElement","clientWidth","vh","clientHeight","targetRect","targetRectXStart","x","targetRectXEnd","targetRectYStart","y","targetRectYEnd","height","targetXMid","targetYMid","targetIsInLeftHalfOfViewport","targetIsInTopHalfOfViewport","offsetFromTargetX","modifiersData","offset","offsetFromTargetY","popoverMaxWidth","popoverMaxHeight","totalScrollableChildHeight","Array","from","elements","children","reduce","sum","el","arrow","scrollHeight","naturalPopoverHeight","Math","max","naturalPopoverWidth","scrollWidth","map","Infinity","resolvedPlacement","style","maxHeight","maxWidth","reset"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/@pega/cosmos-react-core/src/components/Popover/modifiers.ts"],"sourcesContent":["import { Modifier } from '@popperjs/core';\n\nimport { getScrollbarWidth, testElForOverflow } from '../../utils';\n\nexport const sameWidth: Modifier<'sameWidth', object> = Object.freeze({\n  name: 'sameWidth',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn({ state }) {\n    state.styles.popper.width = `${state.rects.reference.width}px`;\n  },\n  requires: ['computeStyles']\n});\n\nconst scrollbarSize = getScrollbarWidth();\n\nexport const placeAndContain: Modifier<'placeAndContain', object> = Object.freeze({\n  name: 'placeAndContain',\n  enabled: true,\n  phase: 'beforeWrite',\n  requires: ['computeStyles', 'offset'],\n  fn: ({ state }) => {\n    const [requestedPrimaryPlacement, requestedSecondaryPlacement] = state.placement.split('-') as [\n      primaryPlacement: 'top' | 'bottom' | 'left' | 'right' | 'auto',\n      secondaryPlacement?: 'start' | 'end' | undefined\n    ];\n\n    const padding = {\n      top: 0,\n      bottom: 0,\n      right: 0,\n      left: 0\n    };\n\n    const preventOverflowPad = state.orderedModifiers.find(({ name }) => name === 'preventOverflow')\n      ?.options?.padding;\n\n    if (typeof preventOverflowPad === 'number') {\n      padding.top = preventOverflowPad;\n      padding.bottom = preventOverflowPad;\n      padding.right = preventOverflowPad;\n      padding.left = preventOverflowPad;\n    } else if (preventOverflowPad) {\n      padding.top = preventOverflowPad.top ?? padding.top;\n      padding.bottom = preventOverflowPad.bottom ?? padding.bottom;\n      padding.right = preventOverflowPad.right ?? padding.right;\n      padding.left = preventOverflowPad.left ?? padding.left;\n    }\n\n    const vw = document.documentElement.clientWidth;\n    const vh = document.documentElement.clientHeight;\n\n    const targetRect = state.rects.reference;\n    const targetRectXStart = targetRect.x;\n    const targetRectXEnd = targetRectXStart + targetRect.width;\n    const targetRectYStart = targetRect.y;\n    const targetRectYEnd = targetRectYStart + targetRect.height;\n    const targetXMid = (targetRectXStart + targetRectXEnd) / 2;\n    const targetYMid = (targetRectYStart + targetRectYEnd) / 2;\n    const targetIsInLeftHalfOfViewport = targetXMid < vw / 2;\n    const targetIsInTopHalfOfViewport = targetYMid < vh / 2;\n\n    const offsetFromTargetX = state.modifiersData.offset?.[state.placement]?.x ?? 0;\n    const offsetFromTargetY = state.modifiersData.offset?.[state.placement]?.y ?? 0;\n\n    let popoverMaxWidth: null | number = null;\n    let popoverMaxHeight: null | number = null;\n\n    const totalScrollableChildHeight = Array.from(state.elements.popper.children).reduce(\n      (sum, el) => {\n        if (el === state.elements.arrow) {\n          return sum;\n        }\n\n        if (testElForOverflow(el)[0]) {\n          return sum + el.scrollHeight + scrollbarSize;\n        }\n\n        return sum + el.scrollHeight;\n      },\n      0\n    );\n\n    const naturalPopoverHeight = Math.max(\n      state.elements.popper.scrollHeight,\n      totalScrollableChildHeight\n    );\n\n    const naturalPopoverWidth = Math.max(\n      state.elements.popper.scrollWidth,\n      ...Array.from(state.elements.popper.children).map(el => {\n        if (el === state.elements.arrow) {\n          return -Infinity;\n        }\n\n        if (testElForOverflow(el)[1]) {\n          return el.scrollWidth + scrollbarSize;\n        }\n\n        return el.scrollWidth;\n      })\n    );\n\n    let resolvedPlacement: `${'top' | 'bottom' | 'left' | 'right' | 'auto'}${\n      | ''\n      | '-start'\n      | '-end'}` = requestedPrimaryPlacement;\n\n    if (requestedPrimaryPlacement === 'bottom') {\n      popoverMaxHeight = vh - targetRectYEnd - offsetFromTargetY - padding.bottom;\n\n      if (\n        // If the popover will overflow the viewport bottom\n        targetRectYEnd + offsetFromTargetY + naturalPopoverHeight >\n        vh\n      ) {\n        // Choose the side with most allowance\n        resolvedPlacement = targetIsInTopHalfOfViewport ? 'bottom' : 'top';\n      }\n    } else if (requestedPrimaryPlacement === 'top') {\n      popoverMaxHeight = targetRectYStart + offsetFromTargetY - padding.top;\n\n      if (\n        // If the popover will overflow the viewport top\n        targetRectYStart + offsetFromTargetY - naturalPopoverHeight <\n        0\n      ) {\n        // Choose the side with most allowance\n        resolvedPlacement = targetIsInTopHalfOfViewport ? 'bottom' : 'top';\n      }\n    } else if (requestedPrimaryPlacement === 'left') {\n      popoverMaxWidth = targetRectXStart + offsetFromTargetX - padding.left;\n\n      if (\n        // If the popover will overflow the viewport left\n        targetRectXStart + offsetFromTargetX - naturalPopoverWidth <\n        0\n      ) {\n        // Choose the side with most allowance\n        resolvedPlacement = targetIsInLeftHalfOfViewport ? 'right' : 'left';\n      }\n    } else if (requestedPrimaryPlacement === 'right') {\n      popoverMaxWidth = vw - targetRectXEnd - offsetFromTargetX - padding.right;\n\n      if (\n        // If the popover will overflow the viewport right\n        targetRectXEnd + offsetFromTargetX + naturalPopoverWidth >\n        vw\n      ) {\n        // Choose the side with most allowance\n        resolvedPlacement = targetIsInLeftHalfOfViewport ? 'right' : 'left';\n      }\n    }\n\n    if (resolvedPlacement === 'left' || resolvedPlacement === 'right') {\n      popoverMaxHeight = vh - padding.top - padding.bottom;\n    }\n\n    state.elements.popper.style.maxHeight = `${popoverMaxHeight}px`;\n\n    state.elements.popper.style.maxWidth = popoverMaxWidth !== null ? `${popoverMaxWidth}px` : '';\n\n    resolvedPlacement = `${resolvedPlacement}${\n      (requestedSecondaryPlacement ? `-${requestedSecondaryPlacement}` : '') as\n        | ''\n        | '-start'\n        | '-end'\n    }`;\n\n    if (state.placement !== resolvedPlacement) {\n      state.placement = resolvedPlacement;\n      state.reset = true;\n    }\n  }\n});\n"],"mappings":"AAEA,SAASA,iBAAiB,EAAEC,iBAAiB,QAAQ,aAAa;AAElE,OAAO,MAAMC,SAAS,GAAkCC,MAAM,CAACC,MAAM,CAAC;EACpEC,IAAI,EAAE,WAAW;EACjBC,OAAO,EAAE,IAAI;EACbC,KAAK,EAAE,aAAa;EACpBC,EAAEA,CAAAC,IAAA,EAAU;IAAA,IAAT;MAAEC;IAAK,CAAE,GAAAD,IAAA;IACVC,KAAK,CAACC,MAAM,CAACC,MAAM,CAACC,KAAK,GAAG,GAAGH,KAAK,CAACI,KAAK,CAACC,SAAS,CAACF,KAAK,IAAI;EAChE,CAAC;EACDG,QAAQ,EAAE,CAAC,eAAe;CAC3B,CAAC;AAEF,MAAMC,aAAa,GAAGjB,iBAAiB,EAAE;AAEzC,OAAO,MAAMkB,eAAe,GAAwCf,MAAM,CAACC,MAAM,CAAC;EAChFC,IAAI,EAAE,iBAAiB;EACvBC,OAAO,EAAE,IAAI;EACbC,KAAK,EAAE,aAAa;EACpBS,QAAQ,EAAE,CAAC,eAAe,EAAE,QAAQ,CAAC;EACrCR,EAAE,EAAEW,KAAA,IAAc;IAAA,IAAb;MAAET;IAAK,CAAE,GAAAS,KAAA;IACZ,MAAM,CAACC,yBAAyB,EAAEC,2BAA2B,CAAC,GAAGX,KAAK,CAACY,SAAS,CAACC,KAAK,CAAC,GAAG,CAGzF;IAED,MAAMC,OAAO,GAAG;MACdC,GAAG,EAAE,CAAC;MACNC,MAAM,EAAE,CAAC;MACTC,KAAK,EAAE,CAAC;MACRC,IAAI,EAAE;KACP;IAED,MAAMC,kBAAkB,GAAGnB,KAAK,CAACoB,gBAAgB,CAACC,IAAI,CAACC,KAAA;MAAA,IAAC;QAAE3B;MAAI,CAAE,GAAA2B,KAAA;MAAA,OAAK3B,IAAI,KAAK,iBAAiB;IAAA,EAAC,EAC5F4B,OAAO,EAAET,OAAO;IAEpB,IAAI,OAAOK,kBAAkB,KAAK,QAAQ,EAAE;MAC1CL,OAAO,CAACC,GAAG,GAAGI,kBAAkB;MAChCL,OAAO,CAACE,MAAM,GAAGG,kBAAkB;MACnCL,OAAO,CAACG,KAAK,GAAGE,kBAAkB;MAClCL,OAAO,CAACI,IAAI,GAAGC,kBAAkB;KAClC,MAAM,IAAIA,kBAAkB,EAAE;MAC7BL,OAAO,CAACC,GAAG,GAAGI,kBAAkB,CAACJ,GAAG,IAAID,OAAO,CAACC,GAAG;MACnDD,OAAO,CAACE,MAAM,GAAGG,kBAAkB,CAACH,MAAM,IAAIF,OAAO,CAACE,MAAM;MAC5DF,OAAO,CAACG,KAAK,GAAGE,kBAAkB,CAACF,KAAK,IAAIH,OAAO,CAACG,KAAK;MACzDH,OAAO,CAACI,IAAI,GAAGC,kBAAkB,CAACD,IAAI,IAAIJ,OAAO,CAACI,IAAI;;IAGxD,MAAMM,EAAE,GAAGC,QAAQ,CAACC,eAAe,CAACC,WAAW;IAC/C,MAAMC,EAAE,GAAGH,QAAQ,CAACC,eAAe,CAACG,YAAY;IAEhD,MAAMC,UAAU,GAAG9B,KAAK,CAACI,KAAK,CAACC,SAAS;IACxC,MAAM0B,gBAAgB,GAAGD,UAAU,CAACE,CAAC;IACrC,MAAMC,cAAc,GAAGF,gBAAgB,GAAGD,UAAU,CAAC3B,KAAK;IAC1D,MAAM+B,gBAAgB,GAAGJ,UAAU,CAACK,CAAC;IACrC,MAAMC,cAAc,GAAGF,gBAAgB,GAAGJ,UAAU,CAACO,MAAM;IAC3D,MAAMC,UAAU,GAAG,CAACP,gBAAgB,GAAGE,cAAc,IAAI,CAAC;IAC1D,MAAMM,UAAU,GAAG,CAACL,gBAAgB,GAAGE,cAAc,IAAI,CAAC;IAC1D,MAAMI,4BAA4B,GAAGF,UAAU,GAAGd,EAAE,GAAG,CAAC;IACxD,MAAMiB,2BAA2B,GAAGF,UAAU,GAAGX,EAAE,GAAG,CAAC;IAEvD,MAAMc,iBAAiB,GAAG1C,KAAK,CAAC2C,aAAa,CAACC,MAAM,GAAG5C,KAAK,CAACY,SAAS,CAAC,EAAEoB,CAAC,IAAI,CAAC;IAC/E,MAAMa,iBAAiB,GAAG7C,KAAK,CAAC2C,aAAa,CAACC,MAAM,GAAG5C,KAAK,CAACY,SAAS,CAAC,EAAEuB,CAAC,IAAI,CAAC;IAE/E,IAAIW,eAAe,GAAkB,IAAI;IACzC,IAAIC,gBAAgB,GAAkB,IAAI;IAE1C,MAAMC,0BAA0B,GAAGC,KAAK,CAACC,IAAI,CAAClD,KAAK,CAACmD,QAAQ,CAACjD,MAAM,CAACkD,QAAQ,CAAC,CAACC,MAAM,CAClF,CAACC,GAAG,EAAEC,EAAE,KAAI;MACV,IAAIA,EAAE,KAAKvD,KAAK,CAACmD,QAAQ,CAACK,KAAK,EAAE;QAC/B,OAAOF,GAAG;;MAGZ,IAAI/D,iBAAiB,CAACgE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE;QAC5B,OAAOD,GAAG,GAAGC,EAAE,CAACE,YAAY,GAAGlD,aAAa;;MAG9C,OAAO+C,GAAG,GAAGC,EAAE,CAACE,YAAY;IAC9B,CAAC,EACD,CAAC,CACF;IAED,MAAMC,oBAAoB,GAAGC,IAAI,CAACC,GAAG,CACnC5D,KAAK,CAACmD,QAAQ,CAACjD,MAAM,CAACuD,YAAY,EAClCT,0BAA0B,CAC3B;IAED,MAAMa,mBAAmB,GAAGF,IAAI,CAACC,GAAG,CAClC5D,KAAK,CAACmD,QAAQ,CAACjD,MAAM,CAAC4D,WAAW,EACjC,GAAGb,KAAK,CAACC,IAAI,CAAClD,KAAK,CAACmD,QAAQ,CAACjD,MAAM,CAACkD,QAAQ,CAAC,CAACW,GAAG,CAACR,EAAE,IAAG;MACrD,IAAIA,EAAE,KAAKvD,KAAK,CAACmD,QAAQ,CAACK,KAAK,EAAE;QAC/B,OAAO,CAACQ,QAAQ;;MAGlB,IAAIzE,iBAAiB,CAACgE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE;QAC5B,OAAOA,EAAE,CAACO,WAAW,GAAGvD,aAAa;;MAGvC,OAAOgD,EAAE,CAACO,WAAW;IACvB,CAAC,CAAC,CACH;IAED,IAAIG,iBAAiB,GAGNvD,yBAAyB;IAExC,IAAIA,yBAAyB,KAAK,QAAQ,EAAE;MAC1CqC,gBAAgB,GAAGnB,EAAE,GAAGQ,cAAc,GAAGS,iBAAiB,GAAG/B,OAAO,CAACE,MAAM;MAE3E;MACE;MACAoB,cAAc,GAAGS,iBAAiB,GAAGa,oBAAoB,GACzD9B,EAAE,EACF;QACA;QACAqC,iBAAiB,GAAGxB,2BAA2B,GAAG,QAAQ,GAAG,KAAK;;KAErE,MAAM,IAAI/B,yBAAyB,KAAK,KAAK,EAAE;MAC9CqC,gBAAgB,GAAGb,gBAAgB,GAAGW,iBAAiB,GAAG/B,OAAO,CAACC,GAAG;MAErE;MACE;MACAmB,gBAAgB,GAAGW,iBAAiB,GAAGa,oBAAoB,GAC3D,CAAC,EACD;QACA;QACAO,iBAAiB,GAAGxB,2BAA2B,GAAG,QAAQ,GAAG,KAAK;;KAErE,MAAM,IAAI/B,yBAAyB,KAAK,MAAM,EAAE;MAC/CoC,eAAe,GAAGf,gBAAgB,GAAGW,iBAAiB,GAAG5B,OAAO,CAACI,IAAI;MAErE;MACE;MACAa,gBAAgB,GAAGW,iBAAiB,GAAGmB,mBAAmB,GAC1D,CAAC,EACD;QACA;QACAI,iBAAiB,GAAGzB,4BAA4B,GAAG,OAAO,GAAG,MAAM;;KAEtE,MAAM,IAAI9B,yBAAyB,KAAK,OAAO,EAAE;MAChDoC,eAAe,GAAGtB,EAAE,GAAGS,cAAc,GAAGS,iBAAiB,GAAG5B,OAAO,CAACG,KAAK;MAEzE;MACE;MACAgB,cAAc,GAAGS,iBAAiB,GAAGmB,mBAAmB,GACxDrC,EAAE,EACF;QACA;QACAyC,iBAAiB,GAAGzB,4BAA4B,GAAG,OAAO,GAAG,MAAM;;;IAIvE,IAAIyB,iBAAiB,KAAK,MAAM,IAAIA,iBAAiB,KAAK,OAAO,EAAE;MACjElB,gBAAgB,GAAGnB,EAAE,GAAGd,OAAO,CAACC,GAAG,GAAGD,OAAO,CAACE,MAAM;;IAGtDhB,KAAK,CAACmD,QAAQ,CAACjD,MAAM,CAACgE,KAAK,CAACC,SAAS,GAAG,GAAGpB,gBAAgB,IAAI;IAE/D/C,KAAK,CAACmD,QAAQ,CAACjD,MAAM,CAACgE,KAAK,CAACE,QAAQ,GAAGtB,eAAe,KAAK,IAAI,GAAG,GAAGA,eAAe,IAAI,GAAG,EAAE;IAE7FmB,iBAAiB,GAAG,GAAGA,iBAAiB,GACrCtD,2BAA2B,GAAG,IAAIA,2BAA2B,EAAE,GAAG,EAIrE,EAAE;IAEF,IAAIX,KAAK,CAACY,SAAS,KAAKqD,iBAAiB,EAAE;MACzCjE,KAAK,CAACY,SAAS,GAAGqD,iBAAiB;MACnCjE,KAAK,CAACqE,KAAK,GAAG,IAAI;;EAEtB;CACD,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}