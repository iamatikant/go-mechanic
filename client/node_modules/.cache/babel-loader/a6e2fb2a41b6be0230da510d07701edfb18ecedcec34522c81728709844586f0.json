{"ast":null,"code":"import { useEffect, useState, useCallback, useRef } from 'react';\nimport { createUID, getActiveElement } from '../utils';\nimport useDirection from './useDirection';\nconst interactiveNodeNames = ['button', 'a', 'input', 'li', 'legend'];\nconst useActiveDescendant = function (_ref) {\n  let {\n    focusEl,\n    scope,\n    scopeSelector,\n    selector,\n    orientation = 'vertical',\n    focusDescendantEl,\n    clearFocusDescendant,\n    focusReturnEl,\n    clearFocusReturn,\n    currentDescendantId,\n    onClick,\n    preventInitialScroll,\n    pauseDescendantEvaluation = false,\n    clearPreventScroll\n  } = _ref;\n  let dependencyArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const [resetId, setResetId] = useState(0);\n  const previousActiveId = useRef('');\n  const paused = useRef(pauseDescendantEvaluation);\n  const [focusDescendantElIndex, setFocusDescendantElIndex] = useState(null);\n  const [currentIndex, setCurrentIndex] = useState(null);\n  const [descendants, setDescendants] = useState();\n  const {\n    rtl\n  } = useDirection();\n  const clearDescendants = useCallback(() => {\n    descendants?.forEach(node => {\n      node.setAttribute('data-current', 'false');\n    });\n  }, [descendants]);\n  const clearThenSetDescendants = useCallback(setVal => {\n    clearDescendants();\n    setDescendants(setVal ? Array.from(setVal).filter(item => item instanceof HTMLElement) : null);\n  }, [descendants]);\n  const setIdsAndOwns = useCallback(function () {\n    let {\n      clear\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      clear: false\n    };\n    const ownedIds = [];\n    if (descendants && descendants.length) {\n      descendants.forEach(node => {\n        node.id = node.id || createUID();\n        ownedIds.push(node.id);\n      });\n    }\n    if (clear) {\n      const currentOwnedIds = focusEl?.getAttribute('aria-owns')?.split(' ');\n      const clearedIds = currentOwnedIds?.filter(id => !ownedIds.includes(id));\n      focusEl?.setAttribute('aria-owns', clearedIds?.join(' ') || '');\n    } else {\n      focusEl?.setAttribute('aria-owns', ownedIds.join(' '));\n    }\n  }, [focusEl, descendants]);\n  const updateDescendants = useCallback(() => {\n    if (pauseDescendantEvaluation) return;\n    let hasScope = scope;\n    if (hasScope && hasScope instanceof HTMLElement) {\n      if (scopeSelector) {\n        hasScope = hasScope.querySelector(scopeSelector);\n      }\n      if (!hasScope) {\n        clearThenSetDescendants(null);\n        return;\n      }\n      if (selector) {\n        const setVal = hasScope.querySelectorAll(selector);\n        clearThenSetDescendants(setVal);\n      } else {\n        const setVal = hasScope.querySelectorAll('a, button, input, textarea, select, details, [tabindex]:not([tabindex=\"-1\"])');\n        clearThenSetDescendants(setVal);\n      }\n    } else {\n      clearThenSetDescendants(null);\n    }\n  }, [scope, scopeSelector, selector, pauseDescendantEvaluation]);\n  // Update paused ref\n  useEffect(() => {\n    paused.current = pauseDescendantEvaluation;\n  }, [pauseDescendantEvaluation]);\n  // Toggle active scope data attr.\n  useEffect(() => {\n    if (!scope || !focusEl) return;\n    scope.setAttribute('data-active-scope', getActiveElement() === focusEl ? 'true' : 'false');\n    const onFocus = () => {\n      scope.setAttribute('data-active-scope', 'true');\n    };\n    const onBlur = () => {\n      scope.setAttribute('data-active-scope', 'false');\n    };\n    focusEl.addEventListener('focus', onFocus);\n    focusEl.addEventListener('blur', onBlur);\n    return () => {\n      focusEl.removeEventListener('focus', onFocus);\n      focusEl.removeEventListener('blur', onBlur);\n    };\n  }, [scope, focusEl]);\n  // Update descendants when un-paused\n  useEffect(() => {\n    if (!pauseDescendantEvaluation) {\n      updateDescendants();\n    }\n  }, [pauseDescendantEvaluation]);\n  // Update descendants & reset current index when dependencies change\n  useEffect(() => {\n    /**\n     * 0 second timeout added because descendantScope needs to be\n     * up to date before running query after dependencyArray change\n     */\n    const timeoutId = setTimeout(() => {\n      updateDescendants();\n      if (!paused.current) {\n        setCurrentIndex(0);\n      }\n    }, 0);\n    return () => clearTimeout(timeoutId);\n  }, [...dependencyArray]);\n  // Set IDs and aria-owns\n  useEffect(() => {\n    if (!pauseDescendantEvaluation) {\n      setIdsAndOwns();\n      setResetId(Math.random());\n    } else {\n      clearDescendants();\n      setIdsAndOwns({\n        clear: true\n      });\n    }\n  }, [pauseDescendantEvaluation, focusEl, descendants]);\n  // Bind focus el keyDown\n  useEffect(() => {\n    const nextIndex = () => {\n      // Focus next or first\n      clearFocusReturn?.();\n      clearPreventScroll?.();\n      if (currentIndex !== null && currentIndex + 1 < descendants.length) {\n        setCurrentIndex(currentIndex + 1);\n      } else {\n        setCurrentIndex(0);\n      }\n    };\n    const prevIndex = () => {\n      // Focus previous or last\n      clearFocusReturn?.();\n      clearPreventScroll?.();\n      if (currentIndex !== null && currentIndex - 1 > -1) {\n        setCurrentIndex(currentIndex - 1);\n      } else {\n        setCurrentIndex(descendants.length - 1);\n      }\n    };\n    const onKeyDown = e => {\n      if (descendants?.length) {\n        if (['ArrowDown', 'ArrowUp'].includes(e.key) && orientation === 'vertical') {\n          e.preventDefault();\n        }\n        if (['ArrowLeft', 'ArrowRight'].includes(e.key) && orientation === 'horizontal') {\n          e.preventDefault();\n        }\n        if (['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp'].includes(e.key)) {\n          e.stopPropagation();\n        }\n        // 0 second timeout to execute after explicitly defined onKeyDown event handlers.\n        setTimeout(() => {\n          switch (e.key) {\n            case 'ArrowDown':\n              if (orientation === 'vertical') {\n                nextIndex();\n              }\n              break;\n            case 'ArrowUp':\n              if (orientation === 'vertical') {\n                prevIndex();\n              }\n              break;\n            case 'ArrowRight':\n              if (orientation === 'horizontal') {\n                if (rtl) {\n                  prevIndex();\n                } else {\n                  nextIndex();\n                }\n              }\n              break;\n            case 'ArrowLeft':\n              if (orientation === 'horizontal') {\n                if (rtl) {\n                  nextIndex();\n                } else {\n                  prevIndex();\n                }\n              }\n              break;\n            case 'Enter':\n              // Click focused item\n              if (currentIndex !== null) {\n                if (onClick) {\n                  onClick(descendants[currentIndex]);\n                  break;\n                }\n                const nodeName = descendants[currentIndex].nodeName.toLowerCase();\n                if (interactiveNodeNames.includes(nodeName)) {\n                  descendants[currentIndex].click();\n                } else {\n                  descendants[currentIndex].querySelector(`${interactiveNodeNames.join(',')}`)?.click();\n                }\n              }\n              break;\n            default:\n              break;\n          }\n        }, 0);\n      }\n    };\n    // Do not rebind once / if `currentDescendantId` (deprecated) control is defined\n    if (!pauseDescendantEvaluation && focusEl && descendants?.length && !currentDescendantId) {\n      focusEl.addEventListener('keydown', onKeyDown);\n    }\n    return () => {\n      focusEl?.removeEventListener('keydown', onKeyDown);\n    };\n  }, [focusEl, currentIndex, descendants, pauseDescendantEvaluation]);\n  // Handle independent control update (deprecated)\n  useEffect(() => {\n    if (!pauseDescendantEvaluation && descendants && currentDescendantId) {\n      descendants.forEach((node, index) => {\n        if (node.id === currentDescendantId) {\n          setCurrentIndex(index);\n        }\n      });\n    }\n  }, [currentDescendantId, descendants, pauseDescendantEvaluation]);\n  // Set and scroll to current descendant\n  useEffect(() => {\n    if (paused.current) {\n      return;\n    }\n    const nextIndex = focusDescendantElIndex || currentIndex;\n    const focusReturnId = focusReturnEl?.id;\n    let focusReturnIndex;\n    const focusDescendantElId = focusDescendantEl?.id;\n    let focusDescendantIndex;\n    let foundFocusDescendantEl = false;\n    if (descendants && descendants.length) {\n      // clear previous & catch focusReturn / focusDescendantEl index\n      descendants.forEach((node, index) => {\n        if (focusDescendantElIndex === null && node.id === focusDescendantElId) {\n          focusDescendantIndex = index;\n          foundFocusDescendantEl = true;\n          setFocusDescendantElIndex(index);\n        }\n        if (node.id === focusReturnId) {\n          focusReturnIndex = index;\n        }\n        node.setAttribute('data-current', 'false');\n      });\n      // early return for focusReturn / focusDescendantEl\n      if (focusReturnIndex && focusReturnIndex !== currentIndex) {\n        setCurrentIndex(focusReturnIndex);\n        clearFocusReturn?.();\n        return;\n      }\n      if (foundFocusDescendantEl && focusDescendantIndex !== undefined) {\n        // hard reset to continue focusDescendantEl process even if it is the active descendant\n        setResetId(Math.random());\n        setCurrentIndex(focusDescendantIndex);\n        return;\n      }\n      // set new\n      if (nextIndex !== null && descendants[nextIndex]) {\n        const itemEl = descendants[nextIndex];\n        itemEl.setAttribute('data-current', 'true');\n        focusEl?.setAttribute('aria-activedescendant', itemEl.id);\n        // scroll to element\n        if (itemEl.id !== previousActiveId.current && !preventInitialScroll) {\n          const scrollTo = Element.prototype.scrollIntoViewIfNeeded ?? Element.prototype.scrollIntoView;\n          scrollTo?.call(itemEl, false);\n        }\n        // focusDescendantEl cleanup\n        if (focusDescendantElIndex !== null) {\n          setFocusDescendantElIndex(null);\n          clearFocusDescendant?.();\n        }\n        previousActiveId.current = itemEl.id;\n      }\n    }\n    return () => {\n      focusEl?.removeAttribute('aria-activedescendant');\n    };\n  }, [descendants, currentIndex, focusDescendantEl, focusEl, resetId]);\n  return {\n    activeDescendant: currentIndex !== null && descendants ? descendants[currentIndex] : undefined,\n    descendants: descendants || null\n  };\n};\nexport const useLazyDescendant = _ref2 => {\n  let {\n    loading,\n    descendants,\n    previousActiveDescendant,\n    activeDescendant,\n    focusReturnEl,\n    setFocusReturnEl,\n    scrollEl\n  } = _ref2;\n  // Bump scroll & set return element when descendant focused in loading state.\n  useEffect(() => {\n    if (loading && descendants && descendants.length && activeDescendant) {\n      const descendantList = [...descendants];\n      const lastItem = descendantList.pop();\n      const lastId = lastItem?.id || undefined;\n      let timeoutId;\n      if (lastId === activeDescendant.id) {\n        if (scrollEl) {\n          scrollEl.scrollTop = scrollEl.scrollHeight - scrollEl.offsetHeight;\n        }\n        if (focusReturnEl?.id !== activeDescendant.id) {\n          // Set focus return to AD on 'nextTick', to avoid reset of AD on update\n          timeoutId = setTimeout(() => {\n            setFocusReturnEl(lastItem);\n          }, 0);\n        }\n      }\n      // If not last item\n      else if (focusReturnEl?.id !== activeDescendant.id) {\n        // Set focus return to AD on 'nextTick' to avoid reset of AD on update\n        // Do not D.R.Y to avoid conflicting calls with immediately prior elements.\n        timeoutId = setTimeout(() => {\n          setFocusReturnEl(activeDescendant);\n        }, 0);\n      }\n      return () => clearTimeout(timeoutId);\n    }\n  }, [loading, descendants, previousActiveDescendant, activeDescendant, scrollEl, focusReturnEl]);\n};\nexport default useActiveDescendant;","map":{"version":3,"names":["useEffect","useState","useCallback","useRef","createUID","getActiveElement","useDirection","interactiveNodeNames","useActiveDescendant","_ref","focusEl","scope","scopeSelector","selector","orientation","focusDescendantEl","clearFocusDescendant","focusReturnEl","clearFocusReturn","currentDescendantId","onClick","preventInitialScroll","pauseDescendantEvaluation","clearPreventScroll","dependencyArray","arguments","length","undefined","resetId","setResetId","previousActiveId","paused","focusDescendantElIndex","setFocusDescendantElIndex","currentIndex","setCurrentIndex","descendants","setDescendants","rtl","clearDescendants","forEach","node","setAttribute","clearThenSetDescendants","setVal","Array","from","filter","item","HTMLElement","setIdsAndOwns","clear","ownedIds","id","push","currentOwnedIds","getAttribute","split","clearedIds","includes","join","updateDescendants","hasScope","querySelector","querySelectorAll","current","onFocus","onBlur","addEventListener","removeEventListener","timeoutId","setTimeout","clearTimeout","Math","random","nextIndex","prevIndex","onKeyDown","e","key","preventDefault","stopPropagation","nodeName","toLowerCase","click","index","focusReturnId","focusReturnIndex","focusDescendantElId","focusDescendantIndex","foundFocusDescendantEl","itemEl","scrollTo","Element","prototype","scrollIntoViewIfNeeded","scrollIntoView","call","removeAttribute","activeDescendant","useLazyDescendant","_ref2","loading","previousActiveDescendant","setFocusReturnEl","scrollEl","descendantList","lastItem","pop","lastId","scrollTop","scrollHeight","offsetHeight"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/@pega/cosmos-react-core/src/hooks/useActiveDescendant.ts"],"sourcesContent":["import { useEffect, useState, DependencyList, useCallback, useRef } from 'react';\n\nimport { createUID, getActiveElement } from '../utils';\n\nimport useDirection from './useDirection';\n\nexport interface UseActiveDescendantConfig {\n  /** DOM element which controls and has active descendants */\n  focusEl: HTMLElement | null;\n  /** Root scope for descendant options */\n  scope: HTMLElement | null;\n  /** Custom selector for specific descendant scope in root descendant scope */\n  scopeSelector?: string;\n  /** Custom selector for descendant options */\n  selector?: string;\n  /** Orientation of descendant navigation\n   * @default 'vertical'\n   */\n  orientation?: 'horizontal' | 'vertical';\n  /** One-time override for the focused descendant, triggers re-evaluation.\n   * Include `clearFocusDescendantEl` for cleanup.\n   */\n  focusDescendantEl?: HTMLElement | null;\n  /** Callback to clear focusDescendantEl after use. */\n  clearFocusDescendant?: () => void;\n  /** One-time override for focused element on NEXT re-evaluation of active descendants.\n   * Include `clearFocusReturn` for cleanup.\n   */\n  focusReturnEl?: HTMLElement | null;\n  /** Callback to clear focusReturnEl after use. */\n  clearFocusReturn?: () => void;\n  /**\n   * Descendant ID used for continuous override of current active descendant,\n   * used for external focus control / keyDown bindings (see RTE).\n   * NOTE: setting currentDescendantId once effectively disables the keybindings of this hook.\n   * If you only need to set the current element once, use focusReturnEl & clearFocusReturn.\n   * @deprecated\n   */\n  currentDescendantId?: string;\n  /** Explicit onClick handler called on keydown 'enter' event */\n  onClick?: (currentDescendantEl: HTMLElement) => void;\n  /** Prevent scrolling to the active descendant on the initial render.\n   * Include `preventInitialScroll` for cleanup.\n   */\n  preventInitialScroll?: boolean;\n  /** Callback to clear preventInitialScroll after use. */\n  clearPreventScroll?: () => void;\n  /** Boolean to prevent descendant evaluation.\n   * @default false\n   */\n  pauseDescendantEvaluation?: boolean;\n}\n\ntype CurrentDescendant = HTMLElement | undefined;\ntype Descendants = HTMLElement[] | null;\ntype InteractiveElementTypes =\n  | HTMLButtonElement\n  | HTMLAnchorElement\n  | HTMLInputElement\n  | HTMLLIElement\n  | HTMLLegendElement;\n\nconst interactiveNodeNames = ['button', 'a', 'input', 'li', 'legend'];\n\nconst useActiveDescendant = (\n  {\n    focusEl,\n    scope,\n    scopeSelector,\n    selector,\n    orientation = 'vertical',\n    focusDescendantEl,\n    clearFocusDescendant,\n    focusReturnEl,\n    clearFocusReturn,\n    currentDescendantId,\n    onClick,\n    preventInitialScroll,\n    pauseDescendantEvaluation = false,\n    clearPreventScroll\n  }: UseActiveDescendantConfig,\n  dependencyArray: DependencyList = []\n): {\n  activeDescendant: CurrentDescendant;\n  descendants: Descendants;\n} => {\n  const [resetId, setResetId] = useState(0);\n  const previousActiveId = useRef('');\n  const paused = useRef(pauseDescendantEvaluation);\n  const [focusDescendantElIndex, setFocusDescendantElIndex] = useState<number | null>(null);\n  const [currentIndex, setCurrentIndex] = useState<number | null>(null);\n  const [descendants, setDescendants] = useState<Descendants>();\n  const { rtl } = useDirection();\n\n  const clearDescendants = useCallback(() => {\n    descendants?.forEach(node => {\n      node.setAttribute('data-current', 'false');\n    });\n  }, [descendants]);\n\n  const clearThenSetDescendants = useCallback(\n    (setVal: NodeListOf<Element> | null) => {\n      clearDescendants();\n      setDescendants(\n        setVal\n          ? Array.from(setVal).filter((item): item is HTMLElement => item instanceof HTMLElement)\n          : null\n      );\n    },\n    [descendants]\n  );\n\n  const setIdsAndOwns = useCallback(\n    ({ clear }: { clear: boolean } = { clear: false }) => {\n      const ownedIds: string[] = [];\n\n      if (descendants && descendants.length) {\n        descendants.forEach(node => {\n          node.id = node.id || createUID();\n          ownedIds.push(node.id);\n        });\n      }\n\n      if (clear) {\n        const currentOwnedIds = focusEl?.getAttribute('aria-owns')?.split(' ');\n        const clearedIds = currentOwnedIds?.filter(id => !ownedIds.includes(id));\n        focusEl?.setAttribute('aria-owns', clearedIds?.join(' ') || '');\n      } else {\n        focusEl?.setAttribute('aria-owns', ownedIds.join(' '));\n      }\n    },\n    [focusEl, descendants]\n  );\n\n  const updateDescendants = useCallback(() => {\n    if (pauseDescendantEvaluation) return;\n\n    let hasScope = scope;\n\n    if (hasScope && hasScope instanceof HTMLElement) {\n      if (scopeSelector) {\n        hasScope = hasScope.querySelector(scopeSelector);\n      }\n\n      if (!hasScope) {\n        clearThenSetDescendants(null);\n        return;\n      }\n\n      if (selector) {\n        const setVal = hasScope.querySelectorAll(selector);\n        clearThenSetDescendants(setVal);\n      } else {\n        const setVal = hasScope.querySelectorAll(\n          'a, button, input, textarea, select, details, [tabindex]:not([tabindex=\"-1\"])'\n        );\n        clearThenSetDescendants(setVal);\n      }\n    } else {\n      clearThenSetDescendants(null);\n    }\n  }, [scope, scopeSelector, selector, pauseDescendantEvaluation]);\n\n  // Update paused ref\n  useEffect(() => {\n    paused.current = pauseDescendantEvaluation;\n  }, [pauseDescendantEvaluation]);\n\n  // Toggle active scope data attr.\n  useEffect(() => {\n    if (!scope || !focusEl) return;\n\n    scope.setAttribute('data-active-scope', getActiveElement() === focusEl ? 'true' : 'false');\n\n    const onFocus = () => {\n      scope.setAttribute('data-active-scope', 'true');\n    };\n    const onBlur = () => {\n      scope.setAttribute('data-active-scope', 'false');\n    };\n\n    focusEl.addEventListener('focus', onFocus);\n    focusEl.addEventListener('blur', onBlur);\n\n    return () => {\n      focusEl.removeEventListener('focus', onFocus);\n      focusEl.removeEventListener('blur', onBlur);\n    };\n  }, [scope, focusEl]);\n\n  // Update descendants when un-paused\n  useEffect(() => {\n    if (!pauseDescendantEvaluation) {\n      updateDescendants();\n    }\n  }, [pauseDescendantEvaluation]);\n\n  // Update descendants & reset current index when dependencies change\n  useEffect(() => {\n    /**\n     * 0 second timeout added because descendantScope needs to be\n     * up to date before running query after dependencyArray change\n     */\n    const timeoutId = setTimeout(() => {\n      updateDescendants();\n      if (!paused.current) {\n        setCurrentIndex(0);\n      }\n    }, 0);\n\n    return () => clearTimeout(timeoutId);\n  }, [...dependencyArray]);\n\n  // Set IDs and aria-owns\n  useEffect(() => {\n    if (!pauseDescendantEvaluation) {\n      setIdsAndOwns();\n      setResetId(Math.random());\n    } else {\n      clearDescendants();\n      setIdsAndOwns({ clear: true });\n    }\n  }, [pauseDescendantEvaluation, focusEl, descendants]);\n\n  // Bind focus el keyDown\n  useEffect(() => {\n    const nextIndex = () => {\n      // Focus next or first\n      clearFocusReturn?.();\n      clearPreventScroll?.();\n      if (currentIndex !== null && currentIndex + 1 < descendants!.length) {\n        setCurrentIndex(currentIndex + 1);\n      } else {\n        setCurrentIndex(0);\n      }\n    };\n    const prevIndex = () => {\n      // Focus previous or last\n      clearFocusReturn?.();\n      clearPreventScroll?.();\n      if (currentIndex !== null && currentIndex - 1 > -1) {\n        setCurrentIndex(currentIndex - 1);\n      } else {\n        setCurrentIndex(descendants!.length - 1);\n      }\n    };\n\n    const onKeyDown = (e: KeyboardEvent) => {\n      if (descendants?.length) {\n        if (['ArrowDown', 'ArrowUp'].includes(e.key) && orientation === 'vertical') {\n          e.preventDefault();\n        }\n\n        if (['ArrowLeft', 'ArrowRight'].includes(e.key) && orientation === 'horizontal') {\n          e.preventDefault();\n        }\n        if (['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp'].includes(e.key)) {\n          e.stopPropagation();\n        }\n\n        // 0 second timeout to execute after explicitly defined onKeyDown event handlers.\n        setTimeout(() => {\n          switch (e.key) {\n            case 'ArrowDown':\n              if (orientation === 'vertical') {\n                nextIndex();\n              }\n              break;\n            case 'ArrowUp':\n              if (orientation === 'vertical') {\n                prevIndex();\n              }\n              break;\n            case 'ArrowRight':\n              if (orientation === 'horizontal') {\n                if (rtl) {\n                  prevIndex();\n                } else {\n                  nextIndex();\n                }\n              }\n              break;\n            case 'ArrowLeft':\n              if (orientation === 'horizontal') {\n                if (rtl) {\n                  nextIndex();\n                } else {\n                  prevIndex();\n                }\n              }\n              break;\n            case 'Enter':\n              // Click focused item\n              if (currentIndex !== null) {\n                if (onClick) {\n                  onClick(descendants[currentIndex]);\n                  break;\n                }\n\n                const nodeName = descendants[currentIndex].nodeName.toLowerCase();\n                if (interactiveNodeNames.includes(nodeName)) {\n                  descendants[currentIndex].click();\n                } else {\n                  descendants[currentIndex]\n                    .querySelector<InteractiveElementTypes>(`${interactiveNodeNames.join(',')}`)\n                    ?.click();\n                }\n              }\n              break;\n            default:\n              break;\n          }\n        }, 0);\n      }\n    };\n\n    // Do not rebind once / if `currentDescendantId` (deprecated) control is defined\n    if (!pauseDescendantEvaluation && focusEl && descendants?.length && !currentDescendantId) {\n      focusEl.addEventListener('keydown', onKeyDown);\n    }\n\n    return () => {\n      focusEl?.removeEventListener('keydown', onKeyDown);\n    };\n  }, [focusEl, currentIndex, descendants, pauseDescendantEvaluation]);\n\n  // Handle independent control update (deprecated)\n  useEffect(() => {\n    if (!pauseDescendantEvaluation && descendants && currentDescendantId) {\n      descendants.forEach((node, index) => {\n        if (node.id === currentDescendantId) {\n          setCurrentIndex(index);\n        }\n      });\n    }\n  }, [currentDescendantId, descendants, pauseDescendantEvaluation]);\n\n  // Set and scroll to current descendant\n  useEffect(() => {\n    if (paused.current) {\n      return;\n    }\n    const nextIndex = focusDescendantElIndex || currentIndex;\n    const focusReturnId = focusReturnEl?.id;\n    let focusReturnIndex;\n    const focusDescendantElId = focusDescendantEl?.id;\n    let focusDescendantIndex;\n    let foundFocusDescendantEl = false;\n\n    if (descendants && descendants.length) {\n      // clear previous & catch focusReturn / focusDescendantEl index\n      descendants.forEach((node, index) => {\n        if (focusDescendantElIndex === null && node.id === focusDescendantElId) {\n          focusDescendantIndex = index;\n          foundFocusDescendantEl = true;\n          setFocusDescendantElIndex(index);\n        }\n        if (node.id === focusReturnId) {\n          focusReturnIndex = index;\n        }\n        node.setAttribute('data-current', 'false');\n      });\n\n      // early return for focusReturn / focusDescendantEl\n      if (focusReturnIndex && focusReturnIndex !== currentIndex) {\n        setCurrentIndex(focusReturnIndex);\n        clearFocusReturn?.();\n        return;\n      }\n      if (foundFocusDescendantEl && focusDescendantIndex !== undefined) {\n        // hard reset to continue focusDescendantEl process even if it is the active descendant\n        setResetId(Math.random());\n        setCurrentIndex(focusDescendantIndex);\n        return;\n      }\n\n      // set new\n      if (nextIndex !== null && descendants[nextIndex]) {\n        const itemEl = descendants[nextIndex!];\n        itemEl.setAttribute('data-current', 'true');\n        focusEl?.setAttribute('aria-activedescendant', itemEl.id);\n\n        // scroll to element\n        if (itemEl.id !== previousActiveId.current && !preventInitialScroll) {\n          const scrollTo: (this: Element, arg: boolean) => void =\n            Element.prototype.scrollIntoViewIfNeeded ?? Element.prototype.scrollIntoView;\n\n          scrollTo?.call(itemEl, false);\n        }\n\n        // focusDescendantEl cleanup\n        if (focusDescendantElIndex !== null) {\n          setFocusDescendantElIndex(null);\n          clearFocusDescendant?.();\n        }\n\n        previousActiveId.current = itemEl.id;\n      }\n    }\n\n    return () => {\n      focusEl?.removeAttribute('aria-activedescendant');\n    };\n  }, [descendants, currentIndex, focusDescendantEl, focusEl, resetId]);\n\n  return {\n    activeDescendant: currentIndex !== null && descendants ? descendants[currentIndex] : undefined,\n    descendants: descendants || null\n  };\n};\n\nexport const useLazyDescendant = ({\n  loading,\n  descendants,\n  previousActiveDescendant,\n  activeDescendant,\n  focusReturnEl,\n  setFocusReturnEl,\n  scrollEl\n}: {\n  loading: boolean;\n  descendants: Descendants;\n  previousActiveDescendant: CurrentDescendant;\n  activeDescendant: CurrentDescendant;\n  focusReturnEl: UseActiveDescendantConfig['focusReturnEl'];\n  setFocusReturnEl: (el: HTMLElement | null | undefined) => void;\n  scrollEl?: HTMLElement | null;\n}) => {\n  // Bump scroll & set return element when descendant focused in loading state.\n  useEffect(() => {\n    if (loading && descendants && descendants.length && activeDescendant) {\n      const descendantList = [...descendants];\n      const lastItem = descendantList.pop();\n      const lastId = lastItem?.id || undefined;\n      let timeoutId: ReturnType<typeof setTimeout>;\n\n      if (lastId === activeDescendant.id) {\n        if (scrollEl) {\n          scrollEl.scrollTop = scrollEl.scrollHeight - scrollEl.offsetHeight;\n        }\n\n        if (focusReturnEl?.id !== activeDescendant.id) {\n          // Set focus return to AD on 'nextTick', to avoid reset of AD on update\n          timeoutId = setTimeout(() => {\n            setFocusReturnEl(lastItem);\n          }, 0);\n        }\n      }\n      // If not last item\n      else if (focusReturnEl?.id !== activeDescendant.id) {\n        // Set focus return to AD on 'nextTick' to avoid reset of AD on update\n        // Do not D.R.Y to avoid conflicting calls with immediately prior elements.\n        timeoutId = setTimeout(() => {\n          setFocusReturnEl(activeDescendant);\n        }, 0);\n      }\n\n      return () => clearTimeout(timeoutId);\n    }\n  }, [loading, descendants, previousActiveDescendant, activeDescendant, scrollEl, focusReturnEl]);\n};\n\nexport default useActiveDescendant;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}