{"ast":null,"code":"import { hasProp, loadScript } from '../../utils';\nimport { CoordsCannotBeParsedError, GeocoderFailedError, GeolocationUnsupportedError, GoogleMapsAPINotFoundError, IsNotAnObjectError, LocationNotFoundError, ProviderNotSupportedError, QUERY_FIELDS, QUERY_TYPES } from './types';\nconst GOOGLE_MAPS_SCRIPT_ID = 'google-map';\nconst providers = {\n  google: {\n    name: 'Google',\n    loadedPromise: null,\n    loadedApiKey: '',\n    loadAPI(opts) {\n      const params = new URLSearchParams(Object.entries({\n        key: opts.apiKey,\n        region: opts.region,\n        language: opts.language,\n        libraries: 'places'\n      }).filter(_ref => {\n        let [, value] = _ref;\n        return value !== undefined;\n      })).toString();\n      const loadedScript = document.getElementById(GOOGLE_MAPS_SCRIPT_ID);\n      if (loadedScript) {\n        loadedScript.remove();\n        // https://stackoverflow.com/questions/29930274/fixing-you-have-included-the-google-maps-api-multiple-times-on-this-page-this\n        delete window.google;\n      }\n      return new Promise((resolve, reject) => {\n        loadScript(`https://maps.googleapis.com/maps/api/js?${params}`, function onLoad() {\n          this.id = GOOGLE_MAPS_SCRIPT_ID;\n          return resolve();\n        }, () => reject(new Error(GoogleMapsAPINotFoundError)));\n      });\n    }\n  },\n  undefined: {\n    name: 'undefined',\n    loadedPromise: null,\n    loadedApiKey: '',\n    loadAPI: data => Promise.reject(new Error(`${ProviderNotSupportedError}: ${data.name}`))\n  }\n};\nexport async function loadMapsAPI() {\n  let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  let opts = arguments.length > 1 ? arguments[1] : undefined;\n  if (typeof opts !== 'object' || !opts) {\n    throw new Error(IsNotAnObjectError);\n  }\n  const provider = providers[name] ?? providers.undefined;\n  if (!provider.loadedPromise || provider.loadedApiKey !== opts?.apiKey) {\n    provider.loadedApiKey = opts?.apiKey;\n    provider.loadedPromise = provider.loadAPI(opts);\n  }\n  return provider.loadedPromise;\n}\nexport async function getNavigatorPosition() {\n  if (!navigator.geolocation) throw new Error(GeolocationUnsupportedError);\n  return new Promise((resolve, reject) => {\n    navigator.geolocation.getCurrentPosition(currentLocation => {\n      resolve({\n        latitude: currentLocation.coords.latitude,\n        longitude: currentLocation.coords.longitude\n      });\n    }, error => reject(new Error(error.message)));\n  });\n}\nexport function toGoogleLatLng(coords) {\n  return new google.maps.LatLng(coords.latitude, coords.longitude);\n}\n/** Returns an array of place prediction objects ('place' can be an establishment, geographic location, or prominent point of interest)\n * and  session token (valid for multiple queries, followed by one place selection).\n */\nexport async function getPlacePredictions(location) {\n  let bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const autocompleteService = new google.maps.places.AutocompleteService();\n  const optionalParams = {};\n  if (bias?.location) {\n    if (bias?.location.center === 'current') {\n      await getNavigatorPosition().then(coords => {\n        optionalParams.location = toGoogleLatLng(coords);\n        optionalParams.radius = bias.location.radius;\n      })\n      // no-op user didn't allow location\n      .catch(() => {});\n    } else {\n      optionalParams.location = toGoogleLatLng(bias.location.center);\n      optionalParams.radius = bias.location.radius;\n    }\n  }\n  if (bias?.bounds) {\n    const [sw, ne] = bias.bounds;\n    optionalParams.bounds = new google.maps.LatLngBounds(toGoogleLatLng(sw), toGoogleLatLng(ne));\n  }\n  return new Promise((resolve, reject) => {\n    const token = new google.maps.places.AutocompleteSessionToken();\n    autocompleteService.getPlacePredictions({\n      input: location,\n      types: QUERY_TYPES,\n      sessionToken: token,\n      ...optionalParams\n    }, (placePredictions, status) => {\n      if (status === google.maps.places.PlacesServiceStatus.OK) {\n        resolve({\n          placePredictions: placePredictions ?? [],\n          token\n        });\n      } else {\n        reject(new Error(LocationNotFoundError));\n      }\n    });\n  });\n}\nexport async function getPlace(location) {\n  let mapElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document.createElement('div');\n  const placesService = new google.maps.places.PlacesService(mapElement);\n  const {\n    placePredictions,\n    token\n  } = await getPlacePredictions(location);\n  return new Promise((resolve, reject) => {\n    placesService.getDetails({\n      placeId: placePredictions[0]?.place_id,\n      fields: QUERY_FIELDS,\n      sessionToken: token\n    }, (place, pStatus) => {\n      if (pStatus === google.maps.places.PlacesServiceStatus.OK) {\n        resolve({\n          latitude: place?.geometry?.location?.lat() || NaN,\n          longitude: place?.geometry?.location?.lng() || NaN\n        });\n      } else {\n        reject(new Error(LocationNotFoundError));\n      }\n    });\n  });\n}\nexport async function getPlaceById(placeId) {\n  let sessionToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new google.maps.places.AutocompleteSessionToken();\n  let mapElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document.createElement('div');\n  const placesService = new google.maps.places.PlacesService(mapElement);\n  return new Promise((resolve, reject) => {\n    placesService.getDetails({\n      placeId,\n      fields: QUERY_FIELDS,\n      sessionToken\n    }, (place, pStatus) => {\n      if (pStatus === google.maps.places.PlacesServiceStatus.OK) {\n        resolve({\n          name: place?.name,\n          address: place?.formatted_address,\n          latitude: place?.geometry?.location?.lat() || NaN,\n          longitude: place?.geometry?.location?.lng() || NaN\n        });\n      } else {\n        reject(new Error(LocationNotFoundError));\n      }\n    });\n  });\n}\n/** Returns coordinations for given input: either coords, address or current position. */\nexport async function getCoords(coords, mapElement) {\n  if (coords === '' || coords === undefined) throw new Error();\n  if (coords === 'current') return getNavigatorPosition();\n  let location;\n  if (typeof coords === 'string') {\n    const [lat, lng] = coords.split(',', 2).map(Number);\n    if (Number.isNaN(lat) || Number.isNaN(lng) || lat === undefined || lng === undefined) return getPlace(coords, mapElement);\n    location = {\n      latitude: lat,\n      longitude: lng\n    };\n  } else {\n    location = coords;\n  }\n  if (Number.isFinite(location.latitude) && Number.isFinite(location.longitude)) return location;\n  throw new Error(CoordsCannotBeParsedError);\n}\nexport async function getAddress(coords) {\n  const location = {\n    lat: coords.latitude,\n    lng: coords.longitude\n  };\n  const geocoder = new google.maps.Geocoder();\n  return new Promise((resolve, reject) => {\n    geocoder.geocode({\n      location\n    }, (results, status) => {\n      if (status === 'OK') {\n        const [result] = results ?? [];\n        if (result) {\n          resolve({\n            name: result.formatted_address,\n            address: result.formatted_address,\n            ...(result.geometry && {\n              latitude: result.geometry.location.lat(),\n              longitude: result.geometry.location.lng()\n            })\n          });\n        } else {\n          resolve({\n            name: `${coords.latitude}, ${coords.longitude}`,\n            latitude: coords.latitude,\n            longitude: coords.longitude\n          });\n        }\n      } else {\n        reject(new Error(`${GeocoderFailedError}: ${status}`));\n      }\n    });\n  });\n}\nexport const isLatLngObject = obj => {\n  return !!obj && typeof obj === 'object' && hasProp(obj, 'lat') && typeof obj.lat === 'function' && hasProp(obj, 'lng') && typeof obj.lng === 'function';\n};","map":{"version":3,"names":["hasProp","loadScript","CoordsCannotBeParsedError","GeocoderFailedError","GeolocationUnsupportedError","GoogleMapsAPINotFoundError","IsNotAnObjectError","LocationNotFoundError","ProviderNotSupportedError","QUERY_FIELDS","QUERY_TYPES","GOOGLE_MAPS_SCRIPT_ID","providers","google","name","loadedPromise","loadedApiKey","loadAPI","opts","params","URLSearchParams","Object","entries","key","apiKey","region","language","libraries","filter","_ref","value","undefined","toString","loadedScript","document","getElementById","remove","window","Promise","resolve","reject","onLoad","id","Error","data","loadMapsAPI","arguments","length","provider","getNavigatorPosition","navigator","geolocation","getCurrentPosition","currentLocation","latitude","coords","longitude","error","message","toGoogleLatLng","maps","LatLng","getPlacePredictions","location","bias","autocompleteService","places","AutocompleteService","optionalParams","center","then","radius","catch","bounds","sw","ne","LatLngBounds","token","AutocompleteSessionToken","input","types","sessionToken","placePredictions","status","PlacesServiceStatus","OK","getPlace","mapElement","createElement","placesService","PlacesService","getDetails","placeId","place_id","fields","place","pStatus","geometry","lat","NaN","lng","getPlaceById","address","formatted_address","getCoords","split","map","Number","isNaN","isFinite","getAddress","geocoder","Geocoder","geocode","results","result","isLatLngObject","obj"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/@pega/cosmos-react-core/src/components/Location/utils.ts"],"sourcesContent":["import { hasProp, loadScript } from '../../utils';\n\nimport {\n  Bias,\n  CoordsCannotBeParsedError,\n  GeocoderFailedError,\n  GeolocationUnsupportedError,\n  GoogleMapsAPINotFoundError,\n  IsNotAnObjectError,\n  LatLng,\n  LocationNotFoundError,\n  MapsProvider,\n  ProviderNotSupportedError,\n  ProviderOpts,\n  QUERY_FIELDS,\n  QUERY_TYPES\n} from './types';\n\nconst GOOGLE_MAPS_SCRIPT_ID = 'google-map';\n\nconst providers: {\n  [key: string]: MapsProvider;\n} = {\n  google: {\n    name: 'Google',\n    loadedPromise: null,\n    loadedApiKey: '',\n    loadAPI(opts) {\n      const params = new URLSearchParams(\n        Object.entries({\n          key: opts.apiKey,\n          region: opts.region,\n          language: opts.language,\n          libraries: 'places'\n        }).filter(([, value]) => value !== undefined)\n      ).toString();\n\n      const loadedScript = document.getElementById(GOOGLE_MAPS_SCRIPT_ID);\n      if (loadedScript) {\n        loadedScript.remove();\n        // https://stackoverflow.com/questions/29930274/fixing-you-have-included-the-google-maps-api-multiple-times-on-this-page-this\n        delete (window as any).google;\n      }\n\n      return new Promise((resolve, reject) => {\n        loadScript(\n          `https://maps.googleapis.com/maps/api/js?${params}`,\n          function onLoad(this: HTMLScriptElement) {\n            this.id = GOOGLE_MAPS_SCRIPT_ID;\n            return resolve();\n          },\n          () => reject(new Error(GoogleMapsAPINotFoundError))\n        );\n      });\n    }\n  },\n  undefined: {\n    name: 'undefined',\n    loadedPromise: null,\n    loadedApiKey: '',\n    loadAPI: data => Promise.reject(new Error(`${ProviderNotSupportedError}: ${data.name}`))\n  }\n};\n\nexport async function loadMapsAPI(name: string = '', opts?: ProviderOpts): Promise<void> {\n  if (typeof opts !== 'object' || !opts) {\n    throw new Error(IsNotAnObjectError);\n  }\n\n  const provider = providers[name] ?? providers.undefined;\n\n  if (!provider.loadedPromise || provider.loadedApiKey !== opts?.apiKey) {\n    provider.loadedApiKey = opts?.apiKey;\n    provider.loadedPromise = provider.loadAPI(opts);\n  }\n  return provider.loadedPromise;\n}\n\nexport async function getNavigatorPosition(): Promise<LatLng> {\n  if (!navigator.geolocation) throw new Error(GeolocationUnsupportedError);\n\n  return new Promise((resolve, reject) => {\n    navigator.geolocation.getCurrentPosition(\n      currentLocation => {\n        resolve({\n          latitude: currentLocation.coords.latitude,\n          longitude: currentLocation.coords.longitude\n        });\n      },\n      error => reject(new Error(error.message))\n    );\n  });\n}\n\nexport function toGoogleLatLng(coords: LatLng): google.maps.LatLng {\n  return new google.maps.LatLng(coords.latitude, coords.longitude);\n}\n\n/** Returns an array of place prediction objects ('place' can be an establishment, geographic location, or prominent point of interest)\n * and  session token (valid for multiple queries, followed by one place selection).\n */\nexport async function getPlacePredictions(\n  location: string,\n  bias: Bias = {}\n): Promise<{\n  placePredictions: google.maps.places.AutocompletePrediction[];\n  token: google.maps.places.AutocompleteSessionToken;\n}> {\n  const autocompleteService = new google.maps.places.AutocompleteService();\n  const optionalParams: Partial<google.maps.places.AutocompletionRequest> = {};\n  if (bias?.location) {\n    if (bias?.location.center === 'current') {\n      await getNavigatorPosition()\n        .then(coords => {\n          optionalParams.location = toGoogleLatLng(coords);\n          optionalParams.radius = bias.location!.radius;\n        })\n        // no-op user didn't allow location\n        .catch(() => {});\n    } else {\n      optionalParams.location = toGoogleLatLng(bias.location.center);\n      optionalParams.radius = bias.location.radius;\n    }\n  }\n\n  if (bias?.bounds) {\n    const [sw, ne] = bias.bounds;\n    optionalParams.bounds = new google.maps.LatLngBounds(toGoogleLatLng(sw), toGoogleLatLng(ne));\n  }\n  return new Promise((resolve, reject) => {\n    const token = new google.maps.places.AutocompleteSessionToken();\n    autocompleteService.getPlacePredictions(\n      {\n        input: location,\n        types: QUERY_TYPES,\n        sessionToken: token,\n        ...optionalParams\n      },\n      (placePredictions, status) => {\n        if (status === google.maps.places.PlacesServiceStatus.OK) {\n          resolve({ placePredictions: placePredictions ?? [], token });\n        } else {\n          reject(new Error(LocationNotFoundError));\n        }\n      }\n    );\n  });\n}\n\nexport async function getPlace(\n  location: string,\n  mapElement: HTMLDivElement = document.createElement('div')\n): Promise<LatLng> {\n  const placesService = new google.maps.places.PlacesService(mapElement);\n  const { placePredictions, token } = await getPlacePredictions(location);\n  return new Promise((resolve, reject) => {\n    placesService.getDetails(\n      { placeId: placePredictions[0]?.place_id, fields: QUERY_FIELDS, sessionToken: token },\n      (place, pStatus) => {\n        if (pStatus === google.maps.places.PlacesServiceStatus.OK) {\n          resolve({\n            latitude: place?.geometry?.location?.lat() || NaN,\n            longitude: place?.geometry?.location?.lng() || NaN\n          });\n        } else {\n          reject(new Error(LocationNotFoundError));\n        }\n      }\n    );\n  });\n}\n\nexport async function getPlaceById(\n  placeId: string,\n  sessionToken: google.maps.places.AutocompleteSessionToken = new google.maps.places.AutocompleteSessionToken(),\n  mapElement: HTMLDivElement = document.createElement('div')\n): Promise<{ name?: string; address?: string; latitude?: number; longitude?: number }> {\n  const placesService = new google.maps.places.PlacesService(mapElement);\n  return new Promise((resolve, reject) => {\n    placesService.getDetails({ placeId, fields: QUERY_FIELDS, sessionToken }, (place, pStatus) => {\n      if (pStatus === google.maps.places.PlacesServiceStatus.OK) {\n        resolve({\n          name: place?.name,\n          address: place?.formatted_address,\n          latitude: place?.geometry?.location?.lat() || NaN,\n          longitude: place?.geometry?.location?.lng() || NaN\n        });\n      } else {\n        reject(new Error(LocationNotFoundError));\n      }\n    });\n  });\n}\n\n/** Returns coordinations for given input: either coords, address or current position. */\nexport async function getCoords(\n  coords: string | LatLng,\n  mapElement?: HTMLDivElement\n): Promise<LatLng> {\n  if (coords === '' || coords === undefined) throw new Error();\n  if (coords === 'current') return getNavigatorPosition();\n\n  let location: LatLng;\n  if (typeof coords === 'string') {\n    const [lat, lng] = coords.split(',', 2).map(Number);\n    if (Number.isNaN(lat) || Number.isNaN(lng) || lat === undefined || lng === undefined)\n      return getPlace(coords, mapElement);\n    location = { latitude: lat, longitude: lng };\n  } else {\n    location = coords;\n  }\n\n  if (Number.isFinite(location.latitude) && Number.isFinite(location.longitude)) return location;\n\n  throw new Error(CoordsCannotBeParsedError);\n}\n\nexport async function getAddress(\n  coords: LatLng\n): Promise<{ name: string; address?: string; latitude?: number; longitude?: number }> {\n  const location = {\n    lat: coords.latitude,\n    lng: coords.longitude\n  };\n  const geocoder = new google.maps.Geocoder();\n  return new Promise((resolve, reject) => {\n    geocoder.geocode(\n      { location },\n      (results: google.maps.GeocoderResult[] | null, status: google.maps.GeocoderStatus) => {\n        if (status === 'OK') {\n          const [result] = results ?? [];\n          if (result) {\n            resolve({\n              name: result.formatted_address,\n              address: result.formatted_address,\n              ...(result.geometry && {\n                latitude: result.geometry.location.lat(),\n                longitude: result.geometry.location.lng()\n              })\n            });\n          } else {\n            resolve({\n              name: `${coords.latitude}, ${coords.longitude}`,\n              latitude: coords.latitude,\n              longitude: coords.longitude\n            });\n          }\n        } else {\n          reject(new Error(`${GeocoderFailedError}: ${status}`));\n        }\n      }\n    );\n  });\n}\n\nexport const isLatLngObject = (obj: any): obj is google.maps.LatLng => {\n  return (\n    !!obj &&\n    typeof obj === 'object' &&\n    hasProp(obj, 'lat') &&\n    typeof obj.lat === 'function' &&\n    hasProp(obj, 'lng') &&\n    typeof obj.lng === 'function'\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}