{"ast":null,"code":"import BigNumber from 'bignumber.js';\nexport function getDecimalSign(locale, options) {\n  return new Intl.NumberFormat(locale, options).formatToParts(0.1).filter(part => part.type === 'decimal')[0]?.value || '';\n}\nexport function getFraction(value) {\n  const decPos = value.indexOf('.');\n  const substrLength = decPos === -1 ? value.length : decPos;\n  return value.substring(substrLength);\n}\nexport function getCleanedValue(value, decimalSign, maximumFractionDigits) {\n  let rawValue = value.replace(new RegExp(`[^${decimalSign}\\\\d-]+`, 'gu'), '');\n  if (decimalSign && decimalSign !== '.') rawValue = rawValue.replace(decimalSign, '.');\n  const match = rawValue.match(new RegExp(`-?\\\\d*(\\\\.\\\\d{0,${maximumFractionDigits}})?`));\n  if (match && match.length > 0) {\n    rawValue = match[0];\n  }\n  return rawValue;\n}\nconst isValidUnit = unit => {\n  try {\n    // eslint-disable-next-line no-new\n    new Intl.NumberFormat(undefined, {\n      style: 'unit',\n      unit\n    });\n    return true;\n  } catch {\n    return false;\n  }\n};\nexport const getFormattedValue = function (value, locale, unit) {\n  let {\n    notation = 'standard',\n    useGrouping = false,\n    maximumFractionDigits,\n    minimumFractionDigits\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const isUnit = unit ? isValidUnit(unit) : false;\n  const [integer, fractionPart] = value.split('.', 2);\n  const formatter = new Intl.NumberFormat(locale, {\n    notation,\n    useGrouping,\n    minimumFractionDigits: minimumFractionDigits ?? Math.min(maximumFractionDigits ?? 0, fractionPart?.length ?? 0),\n    maximumFractionDigits,\n    style: isUnit ? 'unit' : undefined,\n    unit: isUnit ? unit : undefined\n  });\n  let formatted = value;\n  if (value && !Number.isNaN(parseFloat(integer))) {\n    const endsWithDot = fractionPart === '';\n    const valueNumber = Number(endsWithDot ? `${value}1` : value);\n    formatted = formatter.formatToParts(valueNumber).reduce((result, _ref) => {\n      let {\n        type,\n        value: part\n      } = _ref;\n      if (type === 'fraction' && endsWithDot) return result;\n      return result + part;\n    }, '') + (!isUnit && unit ? `\\u00a0${unit}` : '');\n  } else if (unit) {\n    if (isUnit) formatted = formatter.formatToParts(value.startsWith('-') ? -1 : 1).reduce((result, _ref2) => {\n      let {\n        type,\n        value: part\n      } = _ref2;\n      return ['unit', 'minusSign'].includes(type) ? result + part : result;\n    }, '');else formatted = value.startsWith('-') ? `- ${unit}` : unit;\n  }\n  return formatted;\n};\nexport function isValueInRange(value, min, max) {\n  return !(min !== undefined && value < min || max !== undefined && value > max);\n}\nexport function getIncrementedValue(value, min, max, step) {\n  const numberValue = parseFloat(value) || 0;\n  const newValue = new BigNumber(numberValue).plus(step);\n  if (isValueInRange(newValue.toNumber(), min, max)) {\n    return newValue.toFixed();\n  }\n  if (min !== undefined && newValue.toNumber() < min) {\n    return min.toString();\n  }\n  return value;\n}\nexport function getDecrementedValue(value, min, max, step) {\n  const numberValue = parseFloat(value) || 0;\n  const newValue = new BigNumber(numberValue).minus(step);\n  if (isValueInRange(newValue.toNumber(), min, max)) {\n    return newValue.toFixed();\n  }\n  if (max !== undefined && newValue.toNumber() > max) {\n    return max.toString();\n  }\n  return value;\n}\nexport function formatNumber(value, _ref3) {\n  let {\n    locale,\n    options\n  } = _ref3;\n  const formatter = new Intl.NumberFormat(locale, options);\n  return formatter.format(value);\n}","map":{"version":3,"names":["BigNumber","getDecimalSign","locale","options","Intl","NumberFormat","formatToParts","filter","part","type","value","getFraction","decPos","indexOf","substrLength","length","substring","getCleanedValue","decimalSign","maximumFractionDigits","rawValue","replace","RegExp","match","isValidUnit","unit","undefined","style","getFormattedValue","notation","useGrouping","minimumFractionDigits","arguments","isUnit","integer","fractionPart","split","formatter","Math","min","formatted","Number","isNaN","parseFloat","endsWithDot","valueNumber","reduce","result","_ref","startsWith","_ref2","includes","isValueInRange","max","getIncrementedValue","step","numberValue","newValue","plus","toNumber","toFixed","toString","getDecrementedValue","minus","formatNumber","_ref3","format"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/@pega/cosmos-react-core/src/components/Number/utils.ts"],"sourcesContent":["import BigNumber from 'bignumber.js';\n\nexport function getDecimalSign(locale: string, options?: Intl.NumberFormatOptions): string {\n  return (\n    new Intl.NumberFormat(locale, options)\n      .formatToParts(0.1)\n      .filter((part: { type: string; value: string }) => part.type === 'decimal')[0]?.value || ''\n  );\n}\n\nexport function getFraction(value: string) {\n  const decPos = value.indexOf('.');\n  const substrLength = decPos === -1 ? value.length : decPos;\n  return value.substring(substrLength);\n}\n\nexport function getCleanedValue(\n  value: string,\n  decimalSign: string,\n  maximumFractionDigits: number\n): string {\n  let rawValue = value.replace(new RegExp(`[^${decimalSign}\\\\d-]+`, 'gu'), '');\n  if (decimalSign && decimalSign !== '.') rawValue = rawValue.replace(decimalSign, '.');\n  const match = rawValue.match(new RegExp(`-?\\\\d*(\\\\.\\\\d{0,${maximumFractionDigits}})?`));\n  if (match && match.length > 0) {\n    rawValue = match[0];\n  }\n  return rawValue;\n}\n\nconst isValidUnit = (unit: string) => {\n  try {\n    // eslint-disable-next-line no-new\n    new Intl.NumberFormat(undefined, { style: 'unit', unit });\n    return true;\n  } catch {\n    return false;\n  }\n};\n\nexport const getFormattedValue = (\n  value: string,\n  locale: string,\n  unit?: string,\n  {\n    notation = 'standard',\n    useGrouping = false,\n    maximumFractionDigits,\n    minimumFractionDigits\n  }: Pick<\n    Intl.NumberFormatOptions,\n    'notation' | 'useGrouping' | 'maximumFractionDigits' | 'minimumFractionDigits'\n  > = {}\n) => {\n  const isUnit = unit ? isValidUnit(unit) : false;\n  const [integer, fractionPart] = value.split('.', 2) as [string, string?];\n\n  const formatter = new Intl.NumberFormat(locale, {\n    notation,\n    useGrouping,\n    minimumFractionDigits:\n      minimumFractionDigits ?? Math.min(maximumFractionDigits ?? 0, fractionPart?.length ?? 0),\n    maximumFractionDigits,\n    style: isUnit ? 'unit' : undefined,\n    unit: isUnit ? unit : undefined\n  });\n\n  let formatted = value;\n\n  if (value && !Number.isNaN(parseFloat(integer))) {\n    const endsWithDot = fractionPart === '';\n    const valueNumber = Number(endsWithDot ? `${value}1` : value);\n    formatted =\n      formatter.formatToParts(valueNumber).reduce((result, { type, value: part }) => {\n        if (type === 'fraction' && endsWithDot) return result;\n        return result + part;\n      }, '') + (!isUnit && unit ? `\\u00a0${unit}` : '');\n  } else if (unit) {\n    if (isUnit)\n      formatted = formatter\n        .formatToParts(value.startsWith('-') ? -1 : 1)\n        .reduce(\n          (result, { type, value: part }) =>\n            ['unit', 'minusSign'].includes(type) ? result + part : result,\n          ''\n        );\n    else formatted = value.startsWith('-') ? `- ${unit}` : unit;\n  }\n  return formatted;\n};\n\nexport function isValueInRange(value: number, min?: number, max?: number): boolean {\n  return !((min !== undefined && value < min) || (max !== undefined && value > max));\n}\n\nexport function getIncrementedValue(value: string, min: number, max: number, step: number): string {\n  const numberValue = parseFloat(value) || 0;\n  const newValue = new BigNumber(numberValue).plus(step);\n  if (isValueInRange(newValue.toNumber(), min, max)) {\n    return newValue.toFixed();\n  }\n  if (min !== undefined && newValue.toNumber() < min) {\n    return min.toString();\n  }\n  return value;\n}\n\nexport function getDecrementedValue(value: string, min: number, max: number, step: number): string {\n  const numberValue = parseFloat(value) || 0;\n  const newValue = new BigNumber(numberValue).minus(step);\n  if (isValueInRange(newValue.toNumber(), min, max)) {\n    return newValue.toFixed();\n  }\n  if (max !== undefined && newValue.toNumber() > max) {\n    return max.toString();\n  }\n  return value;\n}\n\ninterface NumberFormatOptions {\n  locale: string;\n  options?: Intl.NumberFormatOptions;\n}\n\nexport function formatNumber(value: number | bigint, { locale, options }: NumberFormatOptions) {\n  const formatter = new Intl.NumberFormat(locale, options);\n\n  return formatter.format(value);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}