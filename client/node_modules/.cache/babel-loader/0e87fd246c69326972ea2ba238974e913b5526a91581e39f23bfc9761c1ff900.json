{"ast":null,"code":"const helpers = {\n  getNode(nodes, id) {\n    let found;\n    nodes.some(node => {\n      if (node.id === id) {\n        found = node;\n        return true;\n      }\n      if (node.nodes) {\n        found = this.getNode(node.nodes, id);\n        return !!found;\n      }\n      return false;\n    });\n    return found;\n  },\n  getParentNode(nodes, id) {\n    let found;\n    nodes.some(node => {\n      const childNodes = node.nodes || [];\n      childNodes.some(childNode => {\n        if (childNode.id === id) {\n          found = node;\n          return true;\n        }\n        if (childNode.nodes) {\n          found = this.getParentNode(childNodes, id);\n          return !!found;\n        }\n        return false;\n      });\n      return !!found;\n    });\n    return found;\n  },\n  mapTree(nodes, fn) {\n    return nodes.map((node, index, array) => {\n      let newNode = node;\n      if (node.nodes) {\n        newNode = {\n          ...newNode,\n          nodes: this.mapTree(node.nodes, fn)\n        };\n      }\n      return fn(newNode, index, array);\n    });\n  },\n  forEachNode(nodes, fn) {\n    nodes.forEach((node, index, array) => {\n      if (node.nodes) {\n        this.forEachNode(node.nodes, fn);\n      }\n      fn(node, index, array);\n    });\n  },\n  mapNode(nodes, id, fn) {\n    return nodes.map((node, index, array) => {\n      let newNode = node;\n      if (node.nodes) {\n        newNode = {\n          ...newNode,\n          nodes: this.mapNode(node.nodes, id, fn)\n        };\n      }\n      if (node.id === id) {\n        newNode = fn(newNode, index, array);\n      }\n      return newNode;\n    });\n  },\n  flatten(nodes, ancestors) {\n    return nodes.reduce((flatNodes, node) => {\n      if (node.nodes) {\n        return [...flatNodes, node, ...this.flatten(node.nodes, ancestors ? [...ancestors, node] : [node])];\n      }\n      return [...flatNodes, ancestors ? {\n        ...node,\n        ancestors\n      } : node];\n    }, []);\n  },\n  getAncestors(nodes, id) {\n    let ancestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    const directParent = this.getParentNode(nodes, id);\n    if (directParent) {\n      ancestors.push(directParent);\n      this.getAncestors(nodes, directParent.id, ancestors);\n    }\n    return ancestors;\n  },\n  appendTo(nodes, id, newNodes) {\n    if (id) {\n      return this.mapNode(nodes, id, node => ({\n        ...node,\n        nodes: [...(node.nodes ?? []), ...newNodes]\n      }));\n    }\n    return [...nodes, ...newNodes];\n  },\n  expandTo(nodes, id) {\n    let collapseOthers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return nodes.map(node => {\n      // leaf node\n      if (node.id === id) {\n        return {\n          ...node,\n          expanded: true\n        };\n      }\n      // parent node\n      if (node.nodes) {\n        let expanded = collapseOthers ? false : node.expanded;\n        if (this.getNode(node.nodes, id)) {\n          expanded = true;\n        }\n        return {\n          ...node,\n          nodes: this.expandTo(node.nodes, id, collapseOthers),\n          expanded\n        };\n      }\n      return {\n        ...node,\n        expanded: collapseOthers ? false : node.expanded\n      };\n    });\n  },\n  getFirstChildNode(nodes, id) {\n    let firstChildNode;\n    const node = this.getNode(nodes, id);\n    if (node && node.expanded && node.nodes && node.nodes.length > 0) {\n      const childNodes = node.nodes;\n      firstChildNode = childNodes[0];\n    }\n    return firstChildNode;\n  },\n  getAdjacentNode(nodes, id) {\n    let nextNode;\n    const parent = this.getParentNode(nodes, id);\n    if (parent && parent.nodes && parent.nodes.length > 0) {\n      const childNodes = parent.nodes;\n      const currentIndex = childNodes.map(nodeEl => nodeEl.id).indexOf(id);\n      if (currentIndex === childNodes.length - 1) {\n        nextNode = this.getAdjacentNode(nodes, parent.id);\n      } else {\n        nextNode = childNodes[currentIndex + 1];\n      }\n    } else {\n      const index = nodes.map(nodeEl => nodeEl.id).indexOf(id);\n      nextNode = nodes[index + 1];\n    }\n    return nextNode;\n  },\n  getNextNode(nodes, id) {\n    let nextNode;\n    const firstChildNode = this.getFirstChildNode(nodes, id);\n    if (firstChildNode) {\n      nextNode = firstChildNode;\n    } else {\n      nextNode = this.getAdjacentNode(nodes, id);\n    }\n    return nextNode;\n  },\n  getDeepestNode(nodes, id) {\n    const node = this.getNode(nodes, id);\n    let lastNode = node;\n    if (node && node.expanded && node.nodes && node.nodes.length > 0) {\n      const childNodes = node.nodes;\n      const lastChildNode = childNodes[childNodes.length - 1];\n      if (lastChildNode.expanded) {\n        lastNode = this.getDeepestNode(nodes, lastChildNode.id);\n      } else {\n        lastNode = lastChildNode;\n      }\n    }\n    return lastNode;\n  },\n  getPreviousNode(nodes, id) {\n    const parent = this.getParentNode(nodes, id);\n    let previousNode;\n    if (parent && parent.nodes && parent.nodes.length > 0) {\n      const childNodes = parent.nodes;\n      const currentIndex = childNodes.map(nodeEl => nodeEl.id).indexOf(id);\n      if (currentIndex === 0) {\n        previousNode = parent;\n      } else {\n        previousNode = this.getDeepestNode(nodes, childNodes[currentIndex - 1].id);\n      }\n    } else {\n      const index = nodes.map(node => node.id).indexOf(id);\n      if (nodes[index - 1]) previousNode = this.getDeepestNode(nodes, nodes[index - 1].id);\n    }\n    return previousNode;\n  }\n};\nexport default helpers;","map":{"version":3,"names":["helpers","getNode","nodes","id","found","some","node","getParentNode","childNodes","childNode","mapTree","fn","map","index","array","newNode","forEachNode","forEach","mapNode","flatten","ancestors","reduce","flatNodes","getAncestors","arguments","length","undefined","directParent","push","appendTo","newNodes","expandTo","collapseOthers","expanded","getFirstChildNode","firstChildNode","getAdjacentNode","nextNode","parent","currentIndex","nodeEl","indexOf","getNextNode","getDeepestNode","lastNode","lastChildNode","getPreviousNode","previousNode"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/@pega/cosmos-react-core/src/components/Tree/helpers.ts"],"sourcesContent":["import type { TreeNode } from './Tree';\n\nconst helpers = {\n  getNode<T extends TreeNode = TreeNode>(nodes: T[], id: T['id']): T | undefined {\n    let found;\n    nodes.some(node => {\n      if (node.id === id) {\n        found = node;\n        return true;\n      }\n\n      if (node.nodes) {\n        found = this.getNode(node.nodes, id);\n        return !!found;\n      }\n\n      return false;\n    });\n\n    return found;\n  },\n\n  getParentNode<T extends TreeNode = TreeNode>(nodes: T[], id: T['id']): T | undefined {\n    let found: T | undefined;\n    nodes.some(node => {\n      const childNodes = node.nodes || [];\n      childNodes.some(childNode => {\n        if (childNode.id === id) {\n          found = node;\n          return true;\n        }\n\n        if (childNode.nodes) {\n          found = this.getParentNode(childNodes, id) as T;\n          return !!found;\n        }\n\n        return false;\n      });\n\n      return !!found;\n    });\n\n    return found;\n  },\n\n  mapTree<T1 extends TreeNode = TreeNode, T2 extends TreeNode = T1>(\n    nodes: T1[],\n    fn: (node: T1, index: number, nodes: T1[]) => T2\n  ): T2[] {\n    return nodes.map((node, index, array) => {\n      let newNode = node;\n\n      if (node.nodes) {\n        newNode = {\n          ...newNode,\n          nodes: this.mapTree(node.nodes as T1[], fn)\n        };\n      }\n\n      return fn(newNode, index, array);\n    });\n  },\n\n  forEachNode<T extends TreeNode = TreeNode>(\n    nodes: T[],\n    fn: (node: T, index: number, nodes: T[]) => void\n  ): void {\n    nodes.forEach((node, index, array) => {\n      if (node.nodes) {\n        this.forEachNode(node.nodes as T[], fn);\n      }\n\n      fn(node, index, array);\n    });\n  },\n\n  mapNode<T1 extends TreeNode = TreeNode, T2 extends TreeNode = T1>(\n    nodes: T1[],\n    id: T1['id'],\n    fn: (node: T1, index: number, array: T1[]) => T2\n  ): (T1 | T2)[] {\n    return nodes.map((node, index, array) => {\n      let newNode: T1 | T2 = node;\n\n      if (node.nodes) {\n        newNode = {\n          ...newNode,\n          nodes: this.mapNode(node.nodes as T1[], id, fn)\n        };\n      }\n\n      if (node.id === id) {\n        newNode = fn(newNode, index, array);\n      }\n\n      return newNode;\n    });\n  },\n\n  flatten<T extends TreeNode = TreeNode>(nodes: T[], ancestors?: T[]): (T & { ancestors?: T[] })[] {\n    return nodes.reduce<(T & { ancestors?: T[] })[]>((flatNodes, node) => {\n      if (node.nodes) {\n        return [\n          ...flatNodes,\n          node,\n          ...this.flatten(node.nodes as T[], ancestors ? [...ancestors, node] : [node])\n        ];\n      }\n\n      return [...flatNodes, ancestors ? { ...node, ancestors } : node];\n    }, []);\n  },\n\n  getAncestors<T extends TreeNode = TreeNode>(nodes: T[], id: T['id'], ancestors: T[] = []): T[] {\n    const directParent = this.getParentNode(nodes, id);\n\n    if (directParent) {\n      ancestors.push(directParent);\n      this.getAncestors(nodes, directParent.id, ancestors);\n    }\n\n    return ancestors;\n  },\n\n  appendTo<T extends TreeNode = TreeNode>(nodes: T[], id: T['id'], newNodes: T[]): T[] {\n    if (id) {\n      return this.mapNode(nodes, id, node => ({\n        ...node,\n        nodes: [...(node.nodes ?? []), ...newNodes]\n      }));\n    }\n\n    return [...nodes, ...newNodes];\n  },\n\n  expandTo<T extends TreeNode = TreeNode>(nodes: T[], id: T['id'], collapseOthers = false): T[] {\n    return nodes.map(node => {\n      // leaf node\n      if (node.id === id) {\n        return {\n          ...node,\n          expanded: true\n        };\n      }\n\n      // parent node\n      if (node.nodes) {\n        let expanded = collapseOthers ? false : node.expanded;\n\n        if (this.getNode(node.nodes, id)) {\n          expanded = true;\n        }\n\n        return {\n          ...node,\n          nodes: this.expandTo(node.nodes, id, collapseOthers),\n          expanded\n        };\n      }\n\n      return { ...node, expanded: collapseOthers ? false : node.expanded };\n    });\n  },\n\n  getFirstChildNode<T extends TreeNode = TreeNode>(nodes: T[], id: T['id']): T | undefined {\n    let firstChildNode;\n    const node = this.getNode(nodes, id);\n    if (node && node.expanded && node.nodes && node.nodes.length > 0) {\n      const childNodes = node.nodes as T[];\n      firstChildNode = childNodes[0];\n    }\n    return firstChildNode;\n  },\n\n  getAdjacentNode<T extends TreeNode = TreeNode>(nodes: T[], id: T['id']): T | undefined {\n    let nextNode;\n    const parent = this.getParentNode(nodes, id);\n    if (parent && parent.nodes && parent.nodes.length > 0) {\n      const childNodes = parent.nodes as T[];\n      const currentIndex = childNodes.map(nodeEl => nodeEl.id).indexOf(id);\n      if (currentIndex === childNodes.length - 1) {\n        nextNode = this.getAdjacentNode(nodes, parent.id);\n      } else {\n        nextNode = childNodes[currentIndex + 1];\n      }\n    } else {\n      const index = nodes.map(nodeEl => nodeEl.id).indexOf(id);\n      nextNode = nodes[index + 1];\n    }\n    return nextNode;\n  },\n\n  getNextNode<T extends TreeNode = TreeNode>(nodes: T[], id: T['id']): T | undefined {\n    let nextNode;\n    const firstChildNode = this.getFirstChildNode(nodes, id);\n    if (firstChildNode) {\n      nextNode = firstChildNode;\n    } else {\n      nextNode = this.getAdjacentNode(nodes, id);\n    }\n    return nextNode;\n  },\n\n  getDeepestNode<T extends TreeNode = TreeNode>(nodes: T[], id: T['id']): T | undefined {\n    const node = this.getNode(nodes, id);\n    let lastNode = node;\n    if (node && node.expanded && node.nodes && node.nodes.length > 0) {\n      const childNodes = node.nodes as T[];\n      const lastChildNode = childNodes[childNodes.length - 1];\n      if (lastChildNode.expanded) {\n        lastNode = this.getDeepestNode(nodes, lastChildNode.id);\n      } else {\n        lastNode = lastChildNode;\n      }\n    }\n    return lastNode;\n  },\n\n  getPreviousNode<T extends TreeNode = TreeNode>(nodes: T[], id: T['id']): T | undefined {\n    const parent = this.getParentNode(nodes, id);\n    let previousNode;\n    if (parent && parent.nodes && parent.nodes.length > 0) {\n      const childNodes = parent.nodes;\n      const currentIndex = childNodes.map(nodeEl => nodeEl.id).indexOf(id);\n      if (currentIndex === 0) {\n        previousNode = parent;\n      } else {\n        previousNode = this.getDeepestNode(nodes, childNodes[currentIndex - 1].id);\n      }\n    } else {\n      const index = nodes.map(node => node.id).indexOf(id);\n      if (nodes[index - 1]) previousNode = this.getDeepestNode(nodes, nodes[index - 1].id);\n    }\n    return previousNode;\n  }\n};\n\nexport default helpers;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}