{"ast":null,"code":"import { useRef, useEffect } from 'react';\nimport useEvent from './useEvent';\n/**\n * Formats the raw value using given formatter and handles the caret position.\n * @param ref reference to input element.\n * @param rawValue value to be formatted.\n * @param formatter formatter function accepting partial input and returning partially formatted value.\n * @param acceptableCharacters string containing all the characters that may appear in the value to format. RegExp shorthands are also accepted. Only numbers are accepted by default.\n * @returns formatted value that should be passed to the input component.\n */\nconst useInputFormatter = function (ref, rawValue, formatter) {\n  let acceptableCharacters = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '\\\\p{N}';\n  // synthetic caret position in unformatted value\n  const rawValueCaretPositionRef = useRef();\n  useEvent('keydown', e => {\n    const inputEl = ref.current;\n    if (inputEl) {\n      const caretPositionStart = inputEl.selectionStart ?? 0;\n      const caretPositionEnd = inputEl.selectionEnd ?? 0;\n      const currentValue = inputEl.value;\n      if (caretPositionStart !== caretPositionEnd && ['Backspace', 'Delete'].includes(e.key)) {\n        // if selection contains only formatting characters, move the caret to the beginning of the selection\n        const selectedText = currentValue.slice(caretPositionStart, caretPositionEnd);\n        if (!new RegExp(`[${acceptableCharacters}]`, 'gu').test(selectedText)) {\n          inputEl.setSelectionRange(caretPositionStart, caretPositionStart);\n          e.preventDefault();\n        }\n        return;\n      }\n      if (e.key === 'Backspace' && new RegExp(`[^${acceptableCharacters}]`, 'gu').test(currentValue.charAt(caretPositionStart - 1))) {\n        const lastNonFormatChar = new RegExp(`[${acceptableCharacters}](?=[^${acceptableCharacters}]*$)`, 'gu');\n        // match last non-formatting character if it can be found in the preceding slice\n        if (lastNonFormatChar.test(currentValue.slice(0, caretPositionStart))) {\n          // move the caret after matched character to get it removed\n          inputEl.setSelectionRange(lastNonFormatChar.lastIndex, lastNonFormatChar.lastIndex);\n        } else {\n          e.preventDefault();\n        }\n      }\n      if (e.key === 'Delete' && new RegExp(`[^${acceptableCharacters}]`, 'gu').test(currentValue.charAt(caretPositionEnd))) {\n        const firstNonFormatChar = new RegExp(`[${acceptableCharacters}]`, 'gu');\n        firstNonFormatChar.lastIndex = caretPositionEnd;\n        // find first non-formatting character in the value starting from the caret position\n        if (firstNonFormatChar.test(currentValue)) {\n          // move the caret before matched character to get it removed\n          inputEl.setSelectionRange(firstNonFormatChar.lastIndex - 1, firstNonFormatChar.lastIndex - 1);\n        } else {\n          e.preventDefault();\n        }\n      }\n    }\n  }, {\n    target: ref,\n    dependencies: [acceptableCharacters]\n  });\n  useEvent('input', () => {\n    const inputEl = ref.current;\n    if (inputEl) {\n      // calculate new synthetic caret position in the unformatted value\n      const currentCaretPosition = inputEl.selectionStart ?? 0;\n      rawValueCaretPositionRef.current = inputEl.value.slice(0, currentCaretPosition).replace(new RegExp(`[^${acceptableCharacters}]`, 'gu'), '').length;\n    }\n  }, {\n    target: ref,\n    dependencies: [acceptableCharacters]\n  });\n  useEffect(() => {\n    const inputEl = ref.current;\n    if (inputEl && rawValueCaretPositionRef.current !== undefined) {\n      // create regexp with every raw value character wrapped in possible formatting characters\n      const rawValueRegExpSource = `[^${acceptableCharacters}]*${rawValue.slice(0, rawValueCaretPositionRef.current).split('').join(`[^${acceptableCharacters}]*`)}`;\n      const match = inputEl.value.match(new RegExp(rawValueRegExpSource, 'gu'));\n      if (match) {\n        // if it matches move the real caret to the corresponding index in the raw value\n        inputEl.setSelectionRange(match[0].length, match[0].length);\n      } else {\n        // just re-position the caret otherwise\n        inputEl.setSelectionRange(rawValueCaretPositionRef.current, rawValueCaretPositionRef.current);\n      }\n      rawValueCaretPositionRef.current = undefined;\n    }\n  }, [rawValue, acceptableCharacters]);\n  return formatter(rawValue);\n};\nexport default useInputFormatter;","map":{"version":3,"names":["useRef","useEffect","useEvent","useInputFormatter","ref","rawValue","formatter","acceptableCharacters","arguments","length","undefined","rawValueCaretPositionRef","e","inputEl","current","caretPositionStart","selectionStart","caretPositionEnd","selectionEnd","currentValue","value","includes","key","selectedText","slice","RegExp","test","setSelectionRange","preventDefault","charAt","lastNonFormatChar","lastIndex","firstNonFormatChar","target","dependencies","currentCaretPosition","replace","rawValueRegExpSource","split","join","match"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/@pega/cosmos-react-core/src/hooks/useInputFormatter.ts"],"sourcesContent":["import { RefObject, useRef, useEffect } from 'react';\n\nimport useEvent from './useEvent';\n\n/**\n * Formats the raw value using given formatter and handles the caret position.\n * @param ref reference to input element.\n * @param rawValue value to be formatted.\n * @param formatter formatter function accepting partial input and returning partially formatted value.\n * @param acceptableCharacters string containing all the characters that may appear in the value to format. RegExp shorthands are also accepted. Only numbers are accepted by default.\n * @returns formatted value that should be passed to the input component.\n */\nconst useInputFormatter = (\n  ref: RefObject<HTMLInputElement>,\n  rawValue: string,\n  formatter: (value: string) => string,\n  acceptableCharacters: string = '\\\\p{N}'\n) => {\n  // synthetic caret position in unformatted value\n  const rawValueCaretPositionRef = useRef<number>();\n\n  useEvent(\n    'keydown',\n    e => {\n      const inputEl = ref.current;\n      if (inputEl) {\n        const caretPositionStart = inputEl.selectionStart ?? 0;\n        const caretPositionEnd = inputEl.selectionEnd ?? 0;\n        const currentValue = inputEl.value;\n        if (caretPositionStart !== caretPositionEnd && ['Backspace', 'Delete'].includes(e.key)) {\n          // if selection contains only formatting characters, move the caret to the beginning of the selection\n          const selectedText = currentValue.slice(caretPositionStart, caretPositionEnd);\n          if (!new RegExp(`[${acceptableCharacters}]`, 'gu').test(selectedText)) {\n            inputEl.setSelectionRange(caretPositionStart, caretPositionStart);\n            e.preventDefault();\n          }\n          return;\n        }\n\n        if (\n          e.key === 'Backspace' &&\n          new RegExp(`[^${acceptableCharacters}]`, 'gu').test(\n            currentValue.charAt(caretPositionStart - 1)\n          )\n        ) {\n          const lastNonFormatChar = new RegExp(\n            `[${acceptableCharacters}](?=[^${acceptableCharacters}]*$)`,\n            'gu'\n          );\n          // match last non-formatting character if it can be found in the preceding slice\n          if (lastNonFormatChar.test(currentValue.slice(0, caretPositionStart))) {\n            // move the caret after matched character to get it removed\n            inputEl.setSelectionRange(lastNonFormatChar.lastIndex, lastNonFormatChar.lastIndex);\n          } else {\n            e.preventDefault();\n          }\n        }\n\n        if (\n          e.key === 'Delete' &&\n          new RegExp(`[^${acceptableCharacters}]`, 'gu').test(currentValue.charAt(caretPositionEnd))\n        ) {\n          const firstNonFormatChar = new RegExp(`[${acceptableCharacters}]`, 'gu');\n          firstNonFormatChar.lastIndex = caretPositionEnd;\n          // find first non-formatting character in the value starting from the caret position\n          if (firstNonFormatChar.test(currentValue)) {\n            // move the caret before matched character to get it removed\n            inputEl.setSelectionRange(\n              firstNonFormatChar.lastIndex - 1,\n              firstNonFormatChar.lastIndex - 1\n            );\n          } else {\n            e.preventDefault();\n          }\n        }\n      }\n    },\n    { target: ref, dependencies: [acceptableCharacters] }\n  );\n\n  useEvent(\n    'input',\n    () => {\n      const inputEl = ref.current;\n      if (inputEl) {\n        // calculate new synthetic caret position in the unformatted value\n        const currentCaretPosition = inputEl.selectionStart ?? 0;\n        rawValueCaretPositionRef.current = inputEl.value\n          .slice(0, currentCaretPosition)\n          .replace(new RegExp(`[^${acceptableCharacters}]`, 'gu'), '').length;\n      }\n    },\n    { target: ref, dependencies: [acceptableCharacters] }\n  );\n\n  useEffect(() => {\n    const inputEl = ref.current;\n    if (inputEl && rawValueCaretPositionRef.current !== undefined) {\n      // create regexp with every raw value character wrapped in possible formatting characters\n      const rawValueRegExpSource = `[^${acceptableCharacters}]*${rawValue\n        .slice(0, rawValueCaretPositionRef.current)\n        .split('')\n        .join(`[^${acceptableCharacters}]*`)}`;\n      const match = inputEl.value.match(new RegExp(rawValueRegExpSource, 'gu'));\n      if (match) {\n        // if it matches move the real caret to the corresponding index in the raw value\n        inputEl.setSelectionRange(match[0].length, match[0].length);\n      } else {\n        // just re-position the caret otherwise\n        inputEl.setSelectionRange(\n          rawValueCaretPositionRef.current,\n          rawValueCaretPositionRef.current\n        );\n      }\n      rawValueCaretPositionRef.current = undefined;\n    }\n  }, [rawValue, acceptableCharacters]);\n\n  return formatter(rawValue);\n};\n\nexport default useInputFormatter;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}