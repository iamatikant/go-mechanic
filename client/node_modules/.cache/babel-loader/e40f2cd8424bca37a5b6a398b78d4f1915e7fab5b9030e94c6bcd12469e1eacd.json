{"ast":null,"code":"import { useCallback, useLayoutEffect, useRef } from 'react';\nimport { getScrollbarWidth, testElForOverflow } from '../utils';\nimport useConfiguration from './useConfiguration';\nconst useScrollToggle = function () {\n  let selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ':root';\n  const scrollbarWidthRef = useRef(0);\n  const styleRef = useRef(null);\n  const {\n    styleSheetTarget\n  } = useConfiguration();\n  const enableScroll = useCallback(() => {\n    // No need to short circuit if called repetitively, will just perform a simple null set on the ref.\n    styleRef.current?.remove();\n    styleRef.current = null;\n  }, []);\n  const disableScroll = useCallback(() => {\n    // If we have a ref to the style el we can assume styles to disable overflow are in the DOM. No need for a DOM query.\n    if (styleRef.current) return;\n    const scrollEl = document.querySelector(selector);\n    if (!scrollEl) return;\n    const [overflowX, overflowY] = testElForOverflow(scrollEl);\n    if (!overflowX && !overflowY) return;\n    styleRef.current = document.createElement('style');\n    styleRef.current.textContent = `\n      ${selector} {\n        ${overflowY ? `padding-inline-end: ${scrollbarWidthRef.current}px !important` : ''};\n        ${overflowX ? `padding-block-end: ${scrollbarWidthRef.current}px !important` : ''};\n        overflow: hidden !important;\n      }\n    `;\n    (styleSheetTarget ?? document.head).append(styleRef.current);\n  }, [selector]);\n  useLayoutEffect(() => {\n    scrollbarWidthRef.current = getScrollbarWidth();\n    // To be safe, clean up when the calling component unmounts just in case it did not do so.\n    return enableScroll;\n    // As enableScroll is memoized with no deps, the cleanup **should** only run once on unmount. If that changes, adjust here accordingly.\n  }, [enableScroll]);\n  return {\n    enableScroll,\n    disableScroll\n  };\n};\nexport default useScrollToggle;","map":{"version":3,"names":["useCallback","useLayoutEffect","useRef","getScrollbarWidth","testElForOverflow","useConfiguration","useScrollToggle","selector","arguments","length","undefined","scrollbarWidthRef","styleRef","styleSheetTarget","enableScroll","current","remove","disableScroll","scrollEl","document","querySelector","overflowX","overflowY","createElement","textContent","head","append"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/@pega/cosmos-react-core/src/hooks/useScrollToggle.ts"],"sourcesContent":["import { useCallback, useLayoutEffect, useRef } from 'react';\n\nimport { getScrollbarWidth, testElForOverflow } from '../utils';\n\nimport useConfiguration from './useConfiguration';\n\nconst useScrollToggle = (selector: string = ':root') => {\n  const scrollbarWidthRef = useRef(0);\n  const styleRef = useRef<HTMLStyleElement | null>(null);\n  const { styleSheetTarget } = useConfiguration();\n\n  const enableScroll = useCallback((): void => {\n    // No need to short circuit if called repetitively, will just perform a simple null set on the ref.\n    styleRef.current?.remove();\n    styleRef.current = null;\n  }, []);\n\n  const disableScroll = useCallback((): void => {\n    // If we have a ref to the style el we can assume styles to disable overflow are in the DOM. No need for a DOM query.\n    if (styleRef.current) return;\n    const scrollEl = document.querySelector(selector);\n    if (!scrollEl) return;\n    const [overflowX, overflowY] = testElForOverflow(scrollEl);\n    if (!overflowX && !overflowY) return;\n\n    styleRef.current = document.createElement('style');\n\n    styleRef.current.textContent = `\n      ${selector} {\n        ${overflowY ? `padding-inline-end: ${scrollbarWidthRef.current}px !important` : ''};\n        ${overflowX ? `padding-block-end: ${scrollbarWidthRef.current}px !important` : ''};\n        overflow: hidden !important;\n      }\n    `;\n\n    (styleSheetTarget ?? document.head).append(styleRef.current);\n  }, [selector]);\n\n  useLayoutEffect(() => {\n    scrollbarWidthRef.current = getScrollbarWidth();\n\n    // To be safe, clean up when the calling component unmounts just in case it did not do so.\n    return enableScroll;\n\n    // As enableScroll is memoized with no deps, the cleanup **should** only run once on unmount. If that changes, adjust here accordingly.\n  }, [enableScroll]);\n\n  return { enableScroll, disableScroll };\n};\n\nexport default useScrollToggle;\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,eAAe,EAAEC,MAAM,QAAQ,OAAO;AAE5D,SAASC,iBAAiB,EAAEC,iBAAiB,QAAQ,UAAU;AAE/D,OAAOC,gBAAgB,MAAM,oBAAoB;AAEjD,MAAMC,eAAe,GAAG,SAAAA,CAAA,EAA+B;EAAA,IAA9BC,QAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAmB,OAAO;EACjD,MAAMG,iBAAiB,GAAGT,MAAM,CAAC,CAAC,CAAC;EACnC,MAAMU,QAAQ,GAAGV,MAAM,CAA0B,IAAI,CAAC;EACtD,MAAM;IAAEW;EAAgB,CAAE,GAAGR,gBAAgB,EAAE;EAE/C,MAAMS,YAAY,GAAGd,WAAW,CAAC,MAAW;IAC1C;IACAY,QAAQ,CAACG,OAAO,EAAEC,MAAM,EAAE;IAC1BJ,QAAQ,CAACG,OAAO,GAAG,IAAI;EACzB,CAAC,EAAE,EAAE,CAAC;EAEN,MAAME,aAAa,GAAGjB,WAAW,CAAC,MAAW;IAC3C;IACA,IAAIY,QAAQ,CAACG,OAAO,EAAE;IACtB,MAAMG,QAAQ,GAAGC,QAAQ,CAACC,aAAa,CAACb,QAAQ,CAAC;IACjD,IAAI,CAACW,QAAQ,EAAE;IACf,MAAM,CAACG,SAAS,EAAEC,SAAS,CAAC,GAAGlB,iBAAiB,CAACc,QAAQ,CAAC;IAC1D,IAAI,CAACG,SAAS,IAAI,CAACC,SAAS,EAAE;IAE9BV,QAAQ,CAACG,OAAO,GAAGI,QAAQ,CAACI,aAAa,CAAC,OAAO,CAAC;IAElDX,QAAQ,CAACG,OAAO,CAACS,WAAW,GAAG;QAC3BjB,QAAQ;UACNe,SAAS,GAAG,uBAAuBX,iBAAiB,CAACI,OAAO,eAAe,GAAG,EAAE;UAChFM,SAAS,GAAG,sBAAsBV,iBAAiB,CAACI,OAAO,eAAe,GAAG,EAAE;;;KAGpF;IAED,CAACF,gBAAgB,IAAIM,QAAQ,CAACM,IAAI,EAAEC,MAAM,CAACd,QAAQ,CAACG,OAAO,CAAC;EAC9D,CAAC,EAAE,CAACR,QAAQ,CAAC,CAAC;EAEdN,eAAe,CAAC,MAAK;IACnBU,iBAAiB,CAACI,OAAO,GAAGZ,iBAAiB,EAAE;IAE/C;IACA,OAAOW,YAAY;IAEnB;EACF,CAAC,EAAE,CAACA,YAAY,CAAC,CAAC;EAElB,OAAO;IAAEA,YAAY;IAAEG;EAAa,CAAE;AACxC,CAAC;AAED,eAAeX,eAAe"},"metadata":{},"sourceType":"module","externalDependencies":[]}