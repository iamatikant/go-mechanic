{"ast":null,"code":"import { triple } from '../../utils';\n/**\n * The function accepts ticks map and produces an array of tick definitions. The definition\n * consist of tick value, its label and starting and ending index.\n * Function can stretch the ticks regions to allow more text to fit in the cell.\n * To calculate the stretched regions: {min} and {max} values produce the line which is then\n * divided to equal segments. These segments have indices that correspond to CSS grid cells.\n * Then the indices are optimized in the way that every segment is stretched by the half of length\n * between current tick's index and previous tick's index or next tick's index whichever is smaller.\n * |______________|__________|________________________|\n * 1------^  ^----2----^^----3----^      ^------------4\n * @param ticksMap ticks configuration to calculate ticks definition from\n * @param min minimum allowed value in the range\n * @param max maximum allowed value in the range\n * @param step step in the range\n * @param stretch flag indicating the regions should be stretched\n * @returns ticks definitions array\n */\nexport const calculateTicksRegions = (ticksMap, min, max, step, stretch) => {\n  // calculate initial positions for every tick, the tick segment has the width = 1\n  const defs = Object.entries(ticksMap).filter(_ref => {\n    let [tickValue] = _ref;\n    return Number(tickValue) >= min && Number(tickValue) <= max;\n  }).sort((_ref2, _ref3) => {\n    let [tickValue1] = _ref2;\n    let [tickValue2] = _ref3;\n    return Number(tickValue1) - Number(tickValue2);\n  }).map(_ref4 => {\n    let [tickValue, tickLabel] = _ref4;\n    const cell = (Number(tickValue) - min) / step + 1; // shift by 'min' value, divide by a step and increment, as index starts from 1\n    const cellStart = cell;\n    const cellEnd = cellStart + 1;\n    return {\n      start: cellStart,\n      end: cellEnd,\n      value: Number(tickValue),\n      label: tickLabel\n    };\n  });\n  if (!stretch) return defs;\n  const maxCell = (max - min) / step + 2;\n  const result = [];\n  // extend the tick segments one by one\n  for (const {\n    prev,\n    current,\n    next\n  } of triple(defs)) {\n    let start = current.start;\n    let end = current.end;\n    if (start === 1) {\n      // if the tick is marginal (starting) - expand to the 'right'\n      end = next ? Math.floor((next.start - end) / 2) + end : maxCell;\n    } else if (end === maxCell) {\n      // if the tick is marginal (ending) - expand to the 'left'\n      start = prev ? Math.floor((start - prev.end) / 2) + prev.end : 1;\n    } else {\n      // calculate length between current and prev / next tick and choose the smaller value\n      const length = Math.min(start - (prev?.end ?? 1), (next?.start ?? maxCell) - end);\n      // expand the segment to the left\n      start -= Math.floor(length / 2);\n      // expand to the right\n      end += Math.floor(length / 2);\n    }\n    result.push({\n      start,\n      end,\n      value: current.value,\n      label: current.label\n    });\n  }\n  return result;\n};\n/**\n * Function for given input returns nearest discrete value from a series {min, max}\n * @param input the value to look for nearest value\n * @param step step value determining discrete series\n * @param min minimal value in the series\n * @param max maximum value in the series\n * @returns nearest value as a number\n */\nexport const getNearestValue = (input, min, max, step) => {\n  const output = Math.round(input / step) * step;\n  const decimals = step.toString().split('.')[1]?.length;\n  return Number(output.toFixed(decimals || 0));\n};\n/**\n * Function calculates minimum length of the field where any value from the set of possible values will fit in.\n * @param min minimum value\n * @param max maximum value\n * @param step step in range\n * @returns minimum number of characters the field needs\n */\nexport const calculateValueLength = (min, max, step) => {\n  const [minIntegerPart, minDecimalPart = ''] = min.toString().split('.');\n  const [maxIntegerPart, maxDecimalPart = ''] = max.toString().split('.');\n  const stepDecimalPart = step.toString().split('.')[1] ?? '';\n  return Math.max(minIntegerPart.length, maxIntegerPart.length) + Math.max(maxDecimalPart.length, minDecimalPart.length, stepDecimalPart.length) + (maxDecimalPart || minDecimalPart || stepDecimalPart ? 1 // if there's decimal part, reserve a space for the separator\n  : 0);\n};","map":{"version":3,"names":["triple","calculateTicksRegions","ticksMap","min","max","step","stretch","defs","Object","entries","filter","_ref","tickValue","Number","sort","_ref2","_ref3","tickValue1","tickValue2","map","_ref4","tickLabel","cell","cellStart","cellEnd","start","end","value","label","maxCell","result","prev","current","next","Math","floor","length","push","getNearestValue","input","output","round","decimals","toString","split","toFixed","calculateValueLength","minIntegerPart","minDecimalPart","maxIntegerPart","maxDecimalPart","stepDecimalPart"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/@pega/cosmos-react-core/src/components/Slider/utils.ts"],"sourcesContent":["import { triple } from '../../utils';\n\nimport SliderProps, { TickDefinition } from './Slider.types';\n\n/**\n * The function accepts ticks map and produces an array of tick definitions. The definition\n * consist of tick value, its label and starting and ending index.\n * Function can stretch the ticks regions to allow more text to fit in the cell.\n * To calculate the stretched regions: {min} and {max} values produce the line which is then\n * divided to equal segments. These segments have indices that correspond to CSS grid cells.\n * Then the indices are optimized in the way that every segment is stretched by the half of length\n * between current tick's index and previous tick's index or next tick's index whichever is smaller.\n * |______________|__________|________________________|\n * 1------^  ^----2----^^----3----^      ^------------4\n * @param ticksMap ticks configuration to calculate ticks definition from\n * @param min minimum allowed value in the range\n * @param max maximum allowed value in the range\n * @param step step in the range\n * @param stretch flag indicating the regions should be stretched\n * @returns ticks definitions array\n */\nexport const calculateTicksRegions = (\n  ticksMap: NonNullable<SliderProps['ticks']>,\n  min: number,\n  max: number,\n  step: number,\n  stretch: boolean\n): TickDefinition[] => {\n  // calculate initial positions for every tick, the tick segment has the width = 1\n  const defs = Object.entries(ticksMap)\n    .filter(([tickValue]) => Number(tickValue) >= min && Number(tickValue) <= max)\n    .sort(([tickValue1], [tickValue2]) => Number(tickValue1) - Number(tickValue2))\n    .map(([tickValue, tickLabel]) => {\n      const cell = (Number(tickValue) - min) / step + 1; // shift by 'min' value, divide by a step and increment, as index starts from 1\n      const cellStart = cell;\n      const cellEnd = cellStart + 1;\n      return {\n        start: cellStart,\n        end: cellEnd,\n        value: Number(tickValue),\n        label: tickLabel\n      };\n    });\n\n  if (!stretch) return defs;\n\n  const maxCell = (max - min) / step + 2;\n\n  const result = [];\n  // extend the tick segments one by one\n  for (const { prev, current, next } of triple(defs)) {\n    let start = current.start;\n    let end = current.end;\n    if (start === 1) {\n      // if the tick is marginal (starting) - expand to the 'right'\n      end = next ? Math.floor((next.start - end) / 2) + end : maxCell;\n    } else if (end === maxCell) {\n      // if the tick is marginal (ending) - expand to the 'left'\n      start = prev ? Math.floor((start - prev.end) / 2) + prev.end : 1;\n    } else {\n      // calculate length between current and prev / next tick and choose the smaller value\n      const length = Math.min(start - (prev?.end ?? 1), (next?.start ?? maxCell) - end);\n      // expand the segment to the left\n      start -= Math.floor(length / 2);\n      // expand to the right\n      end += Math.floor(length / 2);\n    }\n    result.push({\n      start,\n      end,\n      value: current.value,\n      label: current.label\n    });\n  }\n\n  return result;\n};\n\n/**\n * Function for given input returns nearest discrete value from a series {min, max}\n * @param input the value to look for nearest value\n * @param step step value determining discrete series\n * @param min minimal value in the series\n * @param max maximum value in the series\n * @returns nearest value as a number\n */\nexport const getNearestValue = (input: number, min: number, max: number, step: number): number => {\n  const output = Math.round(input / step) * step;\n\n  const decimals = step.toString().split('.')[1]?.length;\n  return Number(output.toFixed(decimals || 0));\n};\n\n/**\n * Function calculates minimum length of the field where any value from the set of possible values will fit in.\n * @param min minimum value\n * @param max maximum value\n * @param step step in range\n * @returns minimum number of characters the field needs\n */\nexport const calculateValueLength = (min: number, max: number, step: number): number => {\n  const [minIntegerPart, minDecimalPart = ''] = min.toString().split('.');\n  const [maxIntegerPart, maxDecimalPart = ''] = max.toString().split('.');\n  const stepDecimalPart = step.toString().split('.')[1] ?? '';\n  return (\n    Math.max(minIntegerPart.length, maxIntegerPart.length) +\n    Math.max(maxDecimalPart.length, minDecimalPart.length, stepDecimalPart.length) +\n    (maxDecimalPart || minDecimalPart || stepDecimalPart\n      ? 1 // if there's decimal part, reserve a space for the separator\n      : 0)\n  );\n};\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,aAAa;AAIpC;;;;;;;;;;;;;;;;;AAiBA,OAAO,MAAMC,qBAAqB,GAAGA,CACnCC,QAA2C,EAC3CC,GAAW,EACXC,GAAW,EACXC,IAAY,EACZC,OAAgB,KACI;EACpB;EACA,MAAMC,IAAI,GAAGC,MAAM,CAACC,OAAO,CAACP,QAAQ,CAAC,CAClCQ,MAAM,CAACC,IAAA;IAAA,IAAC,CAACC,SAAS,CAAC,GAAAD,IAAA;IAAA,OAAKE,MAAM,CAACD,SAAS,CAAC,IAAIT,GAAG,IAAIU,MAAM,CAACD,SAAS,CAAC,IAAIR,GAAG;EAAA,EAAC,CAC7EU,IAAI,CAAC,CAAAC,KAAA,EAAAC,KAAA;IAAA,IAAC,CAACC,UAAU,CAAC,GAAAF,KAAA;IAAA,IAAE,CAACG,UAAU,CAAC,GAAAF,KAAA;IAAA,OAAKH,MAAM,CAACI,UAAU,CAAC,GAAGJ,MAAM,CAACK,UAAU,CAAC;EAAA,EAAC,CAC7EC,GAAG,CAACC,KAAA,IAA2B;IAAA,IAA1B,CAACR,SAAS,EAAES,SAAS,CAAC,GAAAD,KAAA;IAC1B,MAAME,IAAI,GAAG,CAACT,MAAM,CAACD,SAAS,CAAC,GAAGT,GAAG,IAAIE,IAAI,GAAG,CAAC,CAAC,CAAC;IACnD,MAAMkB,SAAS,GAAGD,IAAI;IACtB,MAAME,OAAO,GAAGD,SAAS,GAAG,CAAC;IAC7B,OAAO;MACLE,KAAK,EAAEF,SAAS;MAChBG,GAAG,EAAEF,OAAO;MACZG,KAAK,EAAEd,MAAM,CAACD,SAAS,CAAC;MACxBgB,KAAK,EAAEP;KACR;EACH,CAAC,CAAC;EAEJ,IAAI,CAACf,OAAO,EAAE,OAAOC,IAAI;EAEzB,MAAMsB,OAAO,GAAG,CAACzB,GAAG,GAAGD,GAAG,IAAIE,IAAI,GAAG,CAAC;EAEtC,MAAMyB,MAAM,GAAG,EAAE;EACjB;EACA,KAAK,MAAM;IAAEC,IAAI;IAAEC,OAAO;IAAEC;EAAI,CAAE,IAAIjC,MAAM,CAACO,IAAI,CAAC,EAAE;IAClD,IAAIkB,KAAK,GAAGO,OAAO,CAACP,KAAK;IACzB,IAAIC,GAAG,GAAGM,OAAO,CAACN,GAAG;IACrB,IAAID,KAAK,KAAK,CAAC,EAAE;MACf;MACAC,GAAG,GAAGO,IAAI,GAAGC,IAAI,CAACC,KAAK,CAAC,CAACF,IAAI,CAACR,KAAK,GAAGC,GAAG,IAAI,CAAC,CAAC,GAAGA,GAAG,GAAGG,OAAO;KAChE,MAAM,IAAIH,GAAG,KAAKG,OAAO,EAAE;MAC1B;MACAJ,KAAK,GAAGM,IAAI,GAAGG,IAAI,CAACC,KAAK,CAAC,CAACV,KAAK,GAAGM,IAAI,CAACL,GAAG,IAAI,CAAC,CAAC,GAAGK,IAAI,CAACL,GAAG,GAAG,CAAC;KACjE,MAAM;MACL;MACA,MAAMU,MAAM,GAAGF,IAAI,CAAC/B,GAAG,CAACsB,KAAK,IAAIM,IAAI,EAAEL,GAAG,IAAI,CAAC,CAAC,EAAE,CAACO,IAAI,EAAER,KAAK,IAAII,OAAO,IAAIH,GAAG,CAAC;MACjF;MACAD,KAAK,IAAIS,IAAI,CAACC,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC;MAC/B;MACAV,GAAG,IAAIQ,IAAI,CAACC,KAAK,CAACC,MAAM,GAAG,CAAC,CAAC;;IAE/BN,MAAM,CAACO,IAAI,CAAC;MACVZ,KAAK;MACLC,GAAG;MACHC,KAAK,EAAEK,OAAO,CAACL,KAAK;MACpBC,KAAK,EAAEI,OAAO,CAACJ;KAChB,CAAC;;EAGJ,OAAOE,MAAM;AACf,CAAC;AAED;;;;;;;;AAQA,OAAO,MAAMQ,eAAe,GAAGA,CAACC,KAAa,EAAEpC,GAAW,EAAEC,GAAW,EAAEC,IAAY,KAAY;EAC/F,MAAMmC,MAAM,GAAGN,IAAI,CAACO,KAAK,CAACF,KAAK,GAAGlC,IAAI,CAAC,GAAGA,IAAI;EAE9C,MAAMqC,QAAQ,GAAGrC,IAAI,CAACsC,QAAQ,EAAE,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAER,MAAM;EACtD,OAAOvB,MAAM,CAAC2B,MAAM,CAACK,OAAO,CAACH,QAAQ,IAAI,CAAC,CAAC,CAAC;AAC9C,CAAC;AAED;;;;;;;AAOA,OAAO,MAAMI,oBAAoB,GAAGA,CAAC3C,GAAW,EAAEC,GAAW,EAAEC,IAAY,KAAY;EACrF,MAAM,CAAC0C,cAAc,EAAEC,cAAc,GAAG,EAAE,CAAC,GAAG7C,GAAG,CAACwC,QAAQ,EAAE,CAACC,KAAK,CAAC,GAAG,CAAC;EACvE,MAAM,CAACK,cAAc,EAAEC,cAAc,GAAG,EAAE,CAAC,GAAG9C,GAAG,CAACuC,QAAQ,EAAE,CAACC,KAAK,CAAC,GAAG,CAAC;EACvE,MAAMO,eAAe,GAAG9C,IAAI,CAACsC,QAAQ,EAAE,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE;EAC3D,OACEV,IAAI,CAAC9B,GAAG,CAAC2C,cAAc,CAACX,MAAM,EAAEa,cAAc,CAACb,MAAM,CAAC,GACtDF,IAAI,CAAC9B,GAAG,CAAC8C,cAAc,CAACd,MAAM,EAAEY,cAAc,CAACZ,MAAM,EAAEe,eAAe,CAACf,MAAM,CAAC,IAC7Ec,cAAc,IAAIF,cAAc,IAAIG,eAAe,GAChD,CAAC,CAAC;EAAA,EACF,CAAC,CAAC;AAEV,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}