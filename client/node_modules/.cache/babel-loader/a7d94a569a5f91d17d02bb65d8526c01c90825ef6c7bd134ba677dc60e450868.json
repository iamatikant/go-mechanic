{"ast":null,"code":"import { useEffect, useCallback } from 'react';\nimport { documentIsAvailable } from '../utils';\nconst focusable = `\n  a[href],\n  button:enabled,\n  input[type='checkbox']:enabled,\n  input[type='radio']:enabled\n`;\n/**\n * @example useArrows(ref, { cycle, selector });\n * @param ref - A reference to the element that will be navigated through. [React RefObject](https://reactjs.org/docs/refs-and-the-dom.html)\n */\nconst useArrows = function (ref) {\n  let {\n    /** If true, the down or up arrow key will navigate to the first or last element if the element currently focused is the last or first index of the selected elements. */\n    cycle = true,\n    /** A query selector that will determine which elements to cycle through with the arrow keys. The selector will be used in conjunction with [querySelectorAll](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll#selectors). */\n    selector = focusable,\n    /** Which keys are used to navigate through the list */\n    dir = 'up-down',\n    allowTabFocus = true,\n    updateTabIndex = true\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let dependencies = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const [NextKey, PrevKey] = dir === 'up-down' ? ['ArrowDown', 'ArrowUp'] : ['ArrowRight', 'ArrowLeft'];\n  const setTabIndexes = useCallback(el => {\n    // don't set tabindex -1 for first element, or an element with a checked input inside of it to be able to focus it\n    // 0 second timeout added because DOM needs to be up to date after list is updated before running query\n    setTimeout(() => {\n      const focusableElements = Array.from(el.querySelectorAll(selector));\n      if (focusableElements.length > 0) {\n        if (allowTabFocus) focusableElements[0].tabIndex = 0;\n        focusableElements.slice(1).forEach(item => {\n          if (item instanceof HTMLElement) {\n            const checked = item.checked;\n            if (!checked) item.tabIndex = -1;\n          }\n        });\n      }\n    }, 0);\n  }, [selector, ...dependencies]);\n  const listener = useCallback(e => {\n    const el = ref.current;\n    if (!el) return;\n    if (['Home', 'End', NextKey, PrevKey].includes(e.key)) e.preventDefault();\n    if (!documentIsAvailable) return;\n    const items = Array.from(el.querySelectorAll(selector)).filter(item => item instanceof HTMLElement);\n    if (!items.length) return;\n    const rootNode = el.getRootNode();\n    if (!(rootNode instanceof Document) && !(rootNode instanceof ShadowRoot)) return;\n    const focusIdx = items.indexOf(rootNode.activeElement);\n    const lastIdx = items.length - 1;\n    let newFocusIdx;\n    if (e.key === 'Home' || e.key === NextKey && focusIdx === -1) {\n      newFocusIdx = 0;\n    } else if (e.key === 'End' || e.key === PrevKey && focusIdx === -1) {\n      newFocusIdx = lastIdx;\n    } else if (e.key === 'Enter') {\n      if (updateTabIndex) {\n        setTabIndexes(el);\n      }\n      return;\n    } else if (e.key === NextKey) {\n      if (focusIdx === lastIdx) {\n        if (!cycle) return;\n        newFocusIdx = 0;\n      } else {\n        newFocusIdx = focusIdx + 1;\n      }\n    } else if (e.key === PrevKey) {\n      if (focusIdx === 0) {\n        if (!cycle) return;\n        newFocusIdx = lastIdx;\n      } else {\n        newFocusIdx = focusIdx - 1;\n      }\n    } else {\n      return;\n    }\n    items[newFocusIdx].focus();\n  }, [ref.current, cycle, selector, ...dependencies]);\n  useEffect(() => {\n    const el = ref.current;\n    if (!el) return;\n    if (updateTabIndex) {\n      setTabIndexes(el);\n    }\n    el.addEventListener('keydown', listener);\n    return () => {\n      el.removeEventListener('keydown', listener);\n    };\n  }, [ref.current, selector, listener, ...dependencies]);\n};\nexport default useArrows;","map":{"version":3,"names":["useEffect","useCallback","documentIsAvailable","focusable","useArrows","ref","cycle","selector","dir","allowTabFocus","updateTabIndex","arguments","length","undefined","dependencies","NextKey","PrevKey","setTabIndexes","el","setTimeout","focusableElements","Array","from","querySelectorAll","tabIndex","slice","forEach","item","HTMLElement","checked","listener","e","current","includes","key","preventDefault","items","filter","rootNode","getRootNode","Document","ShadowRoot","focusIdx","indexOf","activeElement","lastIdx","newFocusIdx","focus","addEventListener","removeEventListener"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/@pega/cosmos-react-core/src/hooks/useArrows.ts"],"sourcesContent":["import { useEffect, useCallback, RefObject, DependencyList } from 'react';\n\nimport { documentIsAvailable } from '../utils';\n\nconst focusable = `\n  a[href],\n  button:enabled,\n  input[type='checkbox']:enabled,\n  input[type='radio']:enabled\n`;\n\n/**\n * @example useArrows(ref, { cycle, selector });\n * @param ref - A reference to the element that will be navigated through. [React RefObject](https://reactjs.org/docs/refs-and-the-dom.html)\n */\nconst useArrows = (\n  ref: RefObject<HTMLElement>,\n  {\n    /** If true, the down or up arrow key will navigate to the first or last element if the element currently focused is the last or first index of the selected elements. */\n    cycle = true,\n    /** A query selector that will determine which elements to cycle through with the arrow keys. The selector will be used in conjunction with [querySelectorAll](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll#selectors). */\n    selector = focusable,\n    /** Which keys are used to navigate through the list */\n    dir = 'up-down',\n    allowTabFocus = true,\n    updateTabIndex = true\n  }: {\n    cycle?: boolean;\n    selector?: string;\n    dir?: 'up-down' | 'left-right';\n    allowTabFocus?: boolean;\n    updateTabIndex?: boolean;\n  } = {},\n  /** Pass this prop in the internal dependencies when list is dynamic */\n  dependencies: DependencyList = []\n) => {\n  const [NextKey, PrevKey] =\n    dir === 'up-down' ? ['ArrowDown', 'ArrowUp'] : ['ArrowRight', 'ArrowLeft'];\n\n  const setTabIndexes = useCallback(\n    (el: HTMLElement) => {\n      // don't set tabindex -1 for first element, or an element with a checked input inside of it to be able to focus it\n\n      // 0 second timeout added because DOM needs to be up to date after list is updated before running query\n      setTimeout(() => {\n        const focusableElements = Array.from(el.querySelectorAll(selector));\n\n        if (focusableElements.length > 0) {\n          if (allowTabFocus) (focusableElements[0] as HTMLElement).tabIndex = 0;\n          focusableElements.slice(1).forEach(item => {\n            if (item instanceof HTMLElement) {\n              const checked = (item as HTMLInputElement).checked;\n              if (!checked) item.tabIndex = -1;\n            }\n          });\n        }\n      }, 0);\n    },\n    [selector, ...dependencies]\n  );\n\n  const listener = useCallback(\n    (e: KeyboardEvent) => {\n      const el = ref.current;\n      if (!el) return;\n      if (['Home', 'End', NextKey, PrevKey].includes(e.key)) e.preventDefault();\n\n      if (!documentIsAvailable) return;\n\n      const items = Array.from(el.querySelectorAll(selector)).filter(\n        (item): item is HTMLElement => item instanceof HTMLElement\n      );\n\n      if (!items.length) return;\n\n      const rootNode = el.getRootNode();\n\n      if (!(rootNode instanceof Document) && !(rootNode instanceof ShadowRoot)) return;\n\n      const focusIdx = items.indexOf(rootNode.activeElement as HTMLElement);\n      const lastIdx = items.length - 1;\n      let newFocusIdx;\n\n      if (e.key === 'Home' || (e.key === NextKey && focusIdx === -1)) {\n        newFocusIdx = 0;\n      } else if (e.key === 'End' || (e.key === PrevKey && focusIdx === -1)) {\n        newFocusIdx = lastIdx;\n      } else if (e.key === 'Enter') {\n        if (updateTabIndex) {\n          setTabIndexes(el);\n        }\n        return;\n      } else if (e.key === NextKey) {\n        if (focusIdx === lastIdx) {\n          if (!cycle) return;\n          newFocusIdx = 0;\n        } else {\n          newFocusIdx = focusIdx + 1;\n        }\n      } else if (e.key === PrevKey) {\n        if (focusIdx === 0) {\n          if (!cycle) return;\n          newFocusIdx = lastIdx;\n        } else {\n          newFocusIdx = focusIdx - 1;\n        }\n      } else {\n        return;\n      }\n\n      items[newFocusIdx].focus();\n    },\n    [ref.current, cycle, selector, ...dependencies]\n  );\n\n  useEffect(() => {\n    const el = ref.current;\n    if (!el) return;\n    if (updateTabIndex) {\n      setTabIndexes(el);\n    }\n    el.addEventListener('keydown', listener);\n\n    return () => {\n      el.removeEventListener('keydown', listener);\n    };\n  }, [ref.current, selector, listener, ...dependencies]);\n};\n\nexport default useArrows;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}