{"ast":null,"code":"/* IMPORT */\nimport { RESULT } from './constants.js';\nimport Listener from './listener.js';\nimport Shortcut from './shortcut.js';\nimport Utils from './utils.js';\n/* MAIN */\nclass Shortcuts {\n  /* CONSTRUCTOR */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.descriptors = []; //TODO: Implement this more efficiently, possibly reusing the ShortcutsTree structure we already have\n    this.shortcuts = {\n      size: 0,\n      handlers: []\n    };\n    /* PRIVATE API */\n    this._updateListener = () => {\n      const shouldListen = !!this.shortcuts.size;\n      if (shouldListen === this.listener.isListening()) return;\n      shouldListen ? this.listener.on() : this.listener.off();\n    };\n    this.handler = (id, event) => {\n      if (this.recordHandler) {\n        // Recording\n        this.recordHandler(Shortcut.id2accelerator(id));\n        return RESULT.UNHANDLED;\n      }\n      let handleable = false;\n      let firstHandleableIndex = -1;\n      outer: for (let i = 0, l = id.length; i < l; i++) {\n        // Trying all possible combinations (e.g 'A B C' => ['A B C', 'B C ', 'C'])\n        let target = this.shortcuts;\n        for (let ci = i; ci < l; ci++) {\n          // Getting all chords in the current combination\n          target = target[id[ci]];\n          if (!target) {\n            if (!handleable && i === l - 1) return RESULT.UNHANDLEABLE; // Can't be handled by any deeper shortcuts\n            continue outer;\n          }\n        }\n        handleable = true;\n        if (firstHandleableIndex === -1) firstHandleableIndex = i;\n        const {\n          handlers\n        } = target;\n        for (let hi = 0, hl = handlers.length; hi < hl; hi++) {\n          if (handlers[hi](event) === true) {\n            // Handled, stopping here\n            if (event) {\n              event.preventDefault();\n              event.stopPropagation();\n            }\n            return RESULT.HANDLED;\n          }\n        }\n      }\n      if (firstHandleableIndex > 0) {\n        // Simplifying the shortcut, no point in checking unhandleable combinations\n        return id.slice(firstHandleableIndex);\n      } else {\n        return RESULT.UNHANDLED;\n      }\n    };\n    /* PUBLIC API */\n    this.get = () => {\n      return this.descriptors;\n    };\n    this.add = descriptors => {\n      if (!Utils.isArray(descriptors)) return this.add([descriptors]);\n      descriptors.forEach(descriptor => {\n        const {\n          shortcut,\n          handler\n        } = descriptor;\n        if (shortcut[0] === '-') return this.remove([{\n          shortcut,\n          handler\n        }]);\n        if (!handler) return console.error(`Can't add shortcut \"${shortcut}\" which has no handler`);\n        const id = Shortcut.shortcut2id(shortcut);\n        // if ( !Shortcut.checkValidID ( id ) ) return; //TODO: Maybe enable this check, sacrificing some performance for some user friendliness\n        this.descriptors.push(descriptor);\n        const lastIndex = id.length - 1;\n        id.reduce((parent, id, index) => {\n          if (!parent[id]) {\n            parent.size++;\n            parent[id] = {\n              parent,\n              id,\n              size: 0,\n              handlers: []\n            };\n          }\n          if (index === lastIndex) {\n            parent[id].handlers.unshift(handler);\n          }\n          return parent[id];\n        }, this.shortcuts);\n      });\n      this._updateListener();\n    };\n    this.register = descriptors => {\n      this.add(descriptors);\n      return () => {\n        this.remove(descriptors);\n      };\n    };\n    this.remove = descriptors => {\n      if (!Utils.isArray(descriptors)) return this.remove([descriptors]);\n      descriptors.forEach(descriptor => {\n        let {\n          shortcut,\n          handler\n        } = descriptor;\n        if (shortcut[0] === '-') shortcut = shortcut.slice(1);\n        const id = Shortcut.shortcut2id(shortcut);\n        // if ( !Shortcut.checkValidID ( id ) ) return; //TODO: Maybe enable this check, sacrificing some performance for some user friendliness\n        this.descriptors = this.descriptors.filter(d => d.shortcut !== shortcut && !Utils.isEqual(Shortcut.shortcut2id(d.shortcut), id) || handler && d.handler !== handler);\n        const lastIndex = id.length - 1;\n        id.reduce((parent, id, index) => {\n          const child = parent[id];\n          if (!child) return {};\n          if (index === lastIndex) {\n            if (handler) {\n              child.handlers = child.handlers.filter(h => h !== handler);\n            } else {\n              child.handlers.length = 0;\n            }\n            let target = child;\n            while (!target.size && !target.handlers.length && target.parent && target.id) {\n              // Cleaning up\n              delete target.parent[target.id];\n              target.parent.size--;\n              target = target.parent;\n            }\n          }\n          return child;\n        }, this.shortcuts);\n      });\n      this._updateListener();\n    };\n    this.reset = () => {\n      this.descriptors = [];\n      this.shortcuts = {\n        size: 0,\n        handlers: []\n      };\n      this._updateListener();\n    };\n    this.record = handler => {\n      this.recordHandler = handler;\n      return () => {\n        delete this.recordHandler;\n      };\n    };\n    this.trigger = shortcut => {\n      const id = typeof shortcut === 'string' ? Shortcut.shortcut2id(shortcut) : shortcut;\n      // if ( !Shortcut.checkValidID ( id ) ) return RESULT.UNHANDLEABLE; //TODO: Maybe enable this check, sacrificing some performance for some user friendliness\n      return this.handler(id) === RESULT.HANDLED;\n    };\n    this.listener = new Listener({\n      capture: options.capture,\n      handler: this.handler,\n      target: options.target,\n      shouldHandleEvent: options.shouldHandleEvent\n    });\n    this.reset();\n    if (options.shortcuts) {\n      this.add(options.shortcuts);\n    }\n  }\n}\n/* EXPORT */\nexport default Shortcuts;","map":{"version":3,"names":["RESULT","Listener","Shortcut","Utils","Shortcuts","constructor","options","arguments","length","undefined","descriptors","shortcuts","size","handlers","_updateListener","shouldListen","listener","isListening","on","off","handler","id","event","recordHandler","id2accelerator","UNHANDLED","handleable","firstHandleableIndex","outer","i","l","target","ci","UNHANDLEABLE","hi","hl","preventDefault","stopPropagation","HANDLED","slice","get","add","isArray","forEach","descriptor","shortcut","remove","console","error","shortcut2id","push","lastIndex","reduce","parent","index","unshift","register","filter","d","isEqual","child","h","reset","record","trigger","capture","shouldHandleEvent"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/shortcuts/dist/shortcuts.js"],"sourcesContent":["/* IMPORT */\nimport { RESULT } from './constants.js';\nimport Listener from './listener.js';\nimport Shortcut from './shortcut.js';\nimport Utils from './utils.js';\n/* MAIN */\nclass Shortcuts {\n    /* CONSTRUCTOR */\n    constructor(options = {}) {\n        this.descriptors = []; //TODO: Implement this more efficiently, possibly reusing the ShortcutsTree structure we already have\n        this.shortcuts = { size: 0, handlers: [] };\n        /* PRIVATE API */\n        this._updateListener = () => {\n            const shouldListen = !!this.shortcuts.size;\n            if (shouldListen === this.listener.isListening())\n                return;\n            shouldListen ? this.listener.on() : this.listener.off();\n        };\n        this.handler = (id, event) => {\n            if (this.recordHandler) { // Recording\n                this.recordHandler(Shortcut.id2accelerator(id));\n                return RESULT.UNHANDLED;\n            }\n            let handleable = false;\n            let firstHandleableIndex = -1;\n            outer: for (let i = 0, l = id.length; i < l; i++) { // Trying all possible combinations (e.g 'A B C' => ['A B C', 'B C ', 'C'])\n                let target = this.shortcuts;\n                for (let ci = i; ci < l; ci++) { // Getting all chords in the current combination\n                    target = target[id[ci]];\n                    if (!target) {\n                        if (!handleable && i === (l - 1))\n                            return RESULT.UNHANDLEABLE; // Can't be handled by any deeper shortcuts\n                        continue outer;\n                    }\n                }\n                handleable = true;\n                if (firstHandleableIndex === -1)\n                    firstHandleableIndex = i;\n                const { handlers } = target;\n                for (let hi = 0, hl = handlers.length; hi < hl; hi++) {\n                    if (handlers[hi](event) === true) { // Handled, stopping here\n                        if (event) {\n                            event.preventDefault();\n                            event.stopPropagation();\n                        }\n                        return RESULT.HANDLED;\n                    }\n                }\n            }\n            if (firstHandleableIndex > 0) { // Simplifying the shortcut, no point in checking unhandleable combinations\n                return id.slice(firstHandleableIndex);\n            }\n            else {\n                return RESULT.UNHANDLED;\n            }\n        };\n        /* PUBLIC API */\n        this.get = () => {\n            return this.descriptors;\n        };\n        this.add = (descriptors) => {\n            if (!Utils.isArray(descriptors))\n                return this.add([descriptors]);\n            descriptors.forEach(descriptor => {\n                const { shortcut, handler } = descriptor;\n                if (shortcut[0] === '-')\n                    return this.remove([{ shortcut, handler }]);\n                if (!handler)\n                    return console.error(`Can't add shortcut \"${shortcut}\" which has no handler`);\n                const id = Shortcut.shortcut2id(shortcut);\n                // if ( !Shortcut.checkValidID ( id ) ) return; //TODO: Maybe enable this check, sacrificing some performance for some user friendliness\n                this.descriptors.push(descriptor);\n                const lastIndex = id.length - 1;\n                id.reduce((parent, id, index) => {\n                    if (!parent[id]) {\n                        parent.size++;\n                        parent[id] = {\n                            parent,\n                            id,\n                            size: 0,\n                            handlers: []\n                        };\n                    }\n                    if (index === lastIndex) {\n                        parent[id].handlers.unshift(handler);\n                    }\n                    return parent[id];\n                }, this.shortcuts);\n            });\n            this._updateListener();\n        };\n        this.register = (descriptors) => {\n            this.add(descriptors);\n            return () => {\n                this.remove(descriptors);\n            };\n        };\n        this.remove = (descriptors) => {\n            if (!Utils.isArray(descriptors))\n                return this.remove([descriptors]);\n            descriptors.forEach(descriptor => {\n                let { shortcut, handler } = descriptor;\n                if (shortcut[0] === '-')\n                    shortcut = shortcut.slice(1);\n                const id = Shortcut.shortcut2id(shortcut);\n                // if ( !Shortcut.checkValidID ( id ) ) return; //TODO: Maybe enable this check, sacrificing some performance for some user friendliness\n                this.descriptors = this.descriptors.filter(d => (d.shortcut !== shortcut && !Utils.isEqual(Shortcut.shortcut2id(d.shortcut), id)) || (handler && d.handler !== handler));\n                const lastIndex = id.length - 1;\n                id.reduce((parent, id, index) => {\n                    const child = parent[id];\n                    if (!child)\n                        return {};\n                    if (index === lastIndex) {\n                        if (handler) {\n                            child.handlers = child.handlers.filter(h => h !== handler);\n                        }\n                        else {\n                            child.handlers.length = 0;\n                        }\n                        let target = child;\n                        while (!target.size && !target.handlers.length && target.parent && target.id) { // Cleaning up\n                            delete target.parent[target.id];\n                            target.parent.size--;\n                            target = target.parent;\n                        }\n                    }\n                    return child;\n                }, this.shortcuts);\n            });\n            this._updateListener();\n        };\n        this.reset = () => {\n            this.descriptors = [];\n            this.shortcuts = {\n                size: 0,\n                handlers: []\n            };\n            this._updateListener();\n        };\n        this.record = (handler) => {\n            this.recordHandler = handler;\n            return () => {\n                delete this.recordHandler;\n            };\n        };\n        this.trigger = (shortcut) => {\n            const id = typeof shortcut === 'string' ? Shortcut.shortcut2id(shortcut) : shortcut;\n            // if ( !Shortcut.checkValidID ( id ) ) return RESULT.UNHANDLEABLE; //TODO: Maybe enable this check, sacrificing some performance for some user friendliness\n            return this.handler(id) === RESULT.HANDLED;\n        };\n        this.listener = new Listener({\n            capture: options.capture,\n            handler: this.handler,\n            target: options.target,\n            shouldHandleEvent: options.shouldHandleEvent\n        });\n        this.reset();\n        if (options.shortcuts) {\n            this.add(options.shortcuts);\n        }\n    }\n}\n/* EXPORT */\nexport default Shortcuts;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}