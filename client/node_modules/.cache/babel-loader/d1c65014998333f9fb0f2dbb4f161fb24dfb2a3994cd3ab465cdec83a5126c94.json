{"ast":null,"code":"import { parseToHsl, lighten, readableColor, darken, getContrast, hsl, modularScale, stripUnit, math } from 'polished';\nimport { tryCatch } from '../utils';\nexport const getHoverColors = color => {\n  const backgroundLightness = tryCatch(() => parseToHsl(color).lightness, () => 1);\n  let hoverColor = tryCatch(() => lighten(0.1, color));\n  let hoverContrastColor = tryCatch(() => readableColor(lighten(0.1, color)));\n  if (backgroundLightness > 0.35) {\n    hoverColor = tryCatch(() => darken(0.1, color));\n    hoverContrastColor = tryCatch(() => readableColor(darken(0.1, color)));\n  }\n  return {\n    background: hoverColor,\n    foreground: hoverContrastColor\n  };\n};\nconst wcagContrast = {\n  // https://www.w3.org/TR/WCAG21/#contrast-minimum\n  AA: 4.5,\n  AALarge: 3,\n  // https://www.w3.org/TR/WCAG21/#contrast-enhanced\n  AAA: 7,\n  AAALarge: 4.5,\n  // https://www.w3.org/TR/WCAG21/#non-text-contrast\n  AANonText: 3\n};\nexport const readableHue = function (color1, color2) {\n  let {\n    mode = 'both',\n    level = 'AA'\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const minContrast = typeof level === 'string' ? wcagContrast[level] : level;\n  if (getContrast(color1, color2) >= minContrast) return color1;\n  const {\n    lightness,\n    ...hueSaturation\n  } = parseToHsl(color1);\n  let shouldLighten = true;\n  let shouldDarken = true;\n  let lightEnough = '';\n  let darkEnough = '';\n  for (let i = 0; i <= 1; i += 0.01) {\n    if (shouldLighten) {\n      const lightented = hsl({\n        ...hueSaturation,\n        lightness: Math.min(lightness + i, 1)\n      });\n      if (getContrast(lightented, color2) >= minContrast) {\n        if (mode !== 'dark') return lightented;\n        shouldLighten = false;\n        lightEnough = lightented;\n      }\n      if (lightness + i >= 1) shouldLighten = false;\n    }\n    if (shouldDarken) {\n      const darkened = hsl({\n        ...hueSaturation,\n        lightness: Math.max(lightness - i, 0)\n      });\n      if (getContrast(darkened, color2) >= minContrast) {\n        if (mode !== 'light') return darkened;\n        shouldDarken = false;\n        darkEnough = darkened;\n      }\n      if (lightness - i <= 0) shouldDarken = false;\n    }\n    if (!shouldLighten && !shouldDarken) break;\n  }\n  if (lightEnough) return lightEnough;\n  if (darkEnough) return darkEnough;\n  return readableColor(color2);\n};\nexport const omitProps = function () {\n  for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n    props[_key] = arguments[_key];\n  }\n  return {\n    shouldForwardProp: (prop, defaultValidatorFn) => !props.includes(prop) && defaultValidatorFn(prop)\n  };\n};\nconst stepsMap = {\n  xxs: -2,\n  xs: -1,\n  s: 0,\n  m: 1,\n  l: 2,\n  xl: 3,\n  xxl: 4\n};\nexport const calculateFontSize = (baseFontSize, baseFontScale) => {\n  return Object.fromEntries(Object.entries(stepsMap).map(_ref => {\n    let [size, steps] = _ref;\n    const calculation = tryCatch(() => baseFontScale === 'linear' ? math(`${baseFontSize} + (${steps} * 0.0625rem)`) : modularScale(steps, baseFontSize, baseFontScale), () => baseFontSize);\n    if (size === 'xs' && Number.parseFloat(`${stripUnit(calculation)}`) < 0.75) {\n      return [size, `max(calc((${baseFontSize} + 12px) / 2), 12px)`];\n    }\n    return [size, `max(${calculation}, 12px)`];\n  }));\n};","map":{"version":3,"names":["parseToHsl","lighten","readableColor","darken","getContrast","hsl","modularScale","stripUnit","math","tryCatch","getHoverColors","color","backgroundLightness","lightness","hoverColor","hoverContrastColor","background","foreground","wcagContrast","AA","AALarge","AAA","AAALarge","AANonText","readableHue","color1","color2","mode","level","arguments","length","undefined","minContrast","hueSaturation","shouldLighten","shouldDarken","lightEnough","darkEnough","i","lightented","Math","min","darkened","max","omitProps","_len","props","Array","_key","shouldForwardProp","prop","defaultValidatorFn","includes","stepsMap","xxs","xs","s","m","l","xl","xxl","calculateFontSize","baseFontSize","baseFontScale","Object","fromEntries","entries","map","_ref","size","steps","calculation","Number","parseFloat"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/@pega/cosmos-react-core/src/styles/utils.ts"],"sourcesContent":["import { StyledConfig } from 'styled-components';\nimport {\n  parseToHsl,\n  lighten,\n  readableColor,\n  darken,\n  getContrast,\n  hsl,\n  modularScale,\n  stripUnit,\n  math\n} from 'polished';\nimport { ContrastScores } from 'polished/lib/types/color';\nimport { ModularScaleRatio } from 'polished/lib/types/modularScaleRatio';\n\nimport { tryCatch } from '../utils';\n\nexport const getHoverColors = (color: string) => {\n  const backgroundLightness = tryCatch(\n    () => parseToHsl(color).lightness,\n    () => 1\n  );\n  let hoverColor = tryCatch(() => lighten(0.1, color));\n  let hoverContrastColor = tryCatch(() => readableColor(lighten(0.1, color)));\n  if (backgroundLightness > 0.35) {\n    hoverColor = tryCatch(() => darken(0.1, color));\n    hoverContrastColor = tryCatch(() => readableColor(darken(0.1, color)));\n  }\n\n  return { background: hoverColor, foreground: hoverContrastColor };\n};\n\nconst wcagContrast: Record<keyof ContrastScores | 'AANonText', number> = {\n  // https://www.w3.org/TR/WCAG21/#contrast-minimum\n  AA: 4.5,\n  AALarge: 3,\n  // https://www.w3.org/TR/WCAG21/#contrast-enhanced\n  AAA: 7,\n  AAALarge: 4.5,\n  // https://www.w3.org/TR/WCAG21/#non-text-contrast\n  AANonText: 3\n};\n\nexport const readableHue = (\n  color1: string,\n  color2: string,\n  {\n    mode = 'both',\n    level = 'AA'\n  }: { mode?: 'light' | 'dark' | 'both'; level?: keyof typeof wcagContrast | number } = {}\n): string => {\n  const minContrast = typeof level === 'string' ? wcagContrast[level] : level;\n\n  if (getContrast(color1, color2) >= minContrast) return color1;\n\n  const { lightness, ...hueSaturation } = parseToHsl(color1);\n\n  let shouldLighten = true;\n  let shouldDarken = true;\n\n  let lightEnough = '';\n  let darkEnough = '';\n\n  for (let i = 0; i <= 1; i += 0.01) {\n    if (shouldLighten) {\n      const lightented = hsl({\n        ...hueSaturation,\n        lightness: Math.min(lightness + i, 1)\n      });\n\n      if (getContrast(lightented, color2) >= minContrast) {\n        if (mode !== 'dark') return lightented;\n\n        shouldLighten = false;\n        lightEnough = lightented;\n      }\n\n      if (lightness + i >= 1) shouldLighten = false;\n    }\n\n    if (shouldDarken) {\n      const darkened = hsl({\n        ...hueSaturation,\n        lightness: Math.max(lightness - i, 0)\n      });\n\n      if (getContrast(darkened, color2) >= minContrast) {\n        if (mode !== 'light') return darkened;\n\n        shouldDarken = false;\n        darkEnough = darkened;\n      }\n\n      if (lightness - i <= 0) shouldDarken = false;\n    }\n\n    if (!shouldLighten && !shouldDarken) break;\n  }\n\n  if (lightEnough) return lightEnough;\n  if (darkEnough) return darkEnough;\n\n  return readableColor(color2);\n};\n\nexport const omitProps = <O extends object = Record<PropertyKey, unknown>>(\n  ...props: [prop: keyof O, ...props: (keyof O)[]]\n): StyledConfig<O> => ({\n  shouldForwardProp: (prop, defaultValidatorFn) => !props.includes(prop) && defaultValidatorFn(prop)\n});\n\nexport type FontSize = 'xxs' | 'xs' | 's' | 'm' | 'l' | 'xl' | 'xxl';\nconst stepsMap = {\n  xxs: -2,\n  xs: -1,\n  s: 0,\n  m: 1,\n  l: 2,\n  xl: 3,\n  xxl: 4\n};\n\nexport const calculateFontSize = (baseFontSize: string, baseFontScale: string | number) => {\n  return Object.fromEntries(\n    Object.entries(stepsMap).map(([size, steps]) => {\n      const calculation = tryCatch(\n        () =>\n          baseFontScale === 'linear'\n            ? math(`${baseFontSize} + (${steps} * 0.0625rem)`)\n            : modularScale(steps, baseFontSize, baseFontScale as ModularScaleRatio),\n        () => baseFontSize\n      );\n\n      if (size === 'xs' && Number.parseFloat(`${stripUnit(calculation)}`) < 0.75) {\n        return [size, `max(calc((${baseFontSize} + 12px) / 2), 12px)`];\n      }\n\n      return [size, `max(${calculation}, 12px)`];\n    })\n  ) as Record<FontSize, string>;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}