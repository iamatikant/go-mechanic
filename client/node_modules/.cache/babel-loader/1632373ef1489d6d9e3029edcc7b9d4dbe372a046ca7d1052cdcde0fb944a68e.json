{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Stickers_scrollDebounce, _Stickers_resizeDebounce, _Stickers_isWindowScroll, _Stickers_scrollIntervalStart, _Stickers_scrollIntervalChange, _Stickers_scrollDirection, _Stickers_priorScrollY, _Stickers_resizeTimeout, _Stickers_scrollEndTimeout, _Stickers_isScrolling, _Stickers_vpHeightSnapshot, _Stickers_sfHeightSnapshot, _Stickers_stickers, _Stickers_scrollHandler, _Stickers_resizeHandler;\nimport { useRef, useLayoutEffect } from 'react';\nconst onBeforeunload = () => {\n  window.scrollTo(0, 0);\n};\nclass Stickers {\n  constructor(_ref) {\n    let {\n      elements,\n      scrollContainer = window,\n      offset = 0\n    } = _ref;\n    Object.defineProperty(this, \"scrollContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"offset\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    _Stickers_scrollDebounce.set(this, void 0);\n    _Stickers_resizeDebounce.set(this, void 0);\n    _Stickers_isWindowScroll.set(this, void 0);\n    _Stickers_scrollIntervalStart.set(this, void 0);\n    _Stickers_scrollIntervalChange.set(this, void 0);\n    _Stickers_scrollDirection.set(this, void 0);\n    _Stickers_priorScrollY.set(this, void 0);\n    _Stickers_resizeTimeout.set(this, void 0);\n    _Stickers_scrollEndTimeout.set(this, void 0);\n    _Stickers_isScrolling.set(this, void 0);\n    _Stickers_vpHeightSnapshot.set(this, void 0);\n    _Stickers_sfHeightSnapshot.set(this, void 0);\n    _Stickers_stickers.set(this, void 0);\n    _Stickers_scrollHandler.set(this, void 0);\n    _Stickers_resizeHandler.set(this, void 0);\n    this.scrollContainer = scrollContainer;\n    this.offset = offset;\n    __classPrivateFieldSet(this, _Stickers_scrollDebounce, 100, \"f\");\n    __classPrivateFieldSet(this, _Stickers_resizeDebounce, 300, \"f\");\n    __classPrivateFieldSet(this, _Stickers_resizeTimeout, NaN, \"f\");\n    __classPrivateFieldSet(this, _Stickers_scrollEndTimeout, NaN, \"f\");\n    __classPrivateFieldSet(this, _Stickers_priorScrollY, NaN, \"f\");\n    __classPrivateFieldSet(this, _Stickers_isScrolling, false, \"f\");\n    __classPrivateFieldSet(this, _Stickers_vpHeightSnapshot, NaN, \"f\");\n    __classPrivateFieldSet(this, _Stickers_sfHeightSnapshot, NaN, \"f\");\n    __classPrivateFieldSet(this, _Stickers_scrollHandler, () => {}, \"f\");\n    __classPrivateFieldSet(this, _Stickers_resizeHandler, () => {}, \"f\");\n    __classPrivateFieldSet(this, _Stickers_isWindowScroll, this.scrollContainer === window, \"f\");\n    // Only gets reset after scroll stop timeout fires\n    __classPrivateFieldSet(this, _Stickers_scrollIntervalStart, this.getScrollY(), \"f\");\n    // Used to determine scroll change within debounced scroll handler\n    __classPrivateFieldSet(this, _Stickers_scrollIntervalChange, 0, \"f\");\n    // Used to determine scroll direction by +1(page down) -1(page up)\n    __classPrivateFieldSet(this, _Stickers_scrollDirection, 0, \"f\");\n    __classPrivateFieldSet(this, _Stickers_stickers, this.setStickers(elements), \"f\");\n    this.snapshotItemRects();\n    this.addHandlers();\n  }\n  setStickers(elements) {\n    __classPrivateFieldSet(this, _Stickers_stickers, (typeof elements === 'string' ? Array.from(document.querySelectorAll(elements)) : elements).map(element => ({\n      element,\n      isStuck: false,\n      top: NaN,\n      bottom: NaN,\n      height: NaN,\n      priorStickHeight: NaN\n    })), \"f\");\n    return __classPrivateFieldGet(this, _Stickers_stickers, \"f\");\n  }\n  addHandlers() {\n    this.rmHandlers();\n    __classPrivateFieldSet(this, _Stickers_scrollHandler, this.onScroll.bind(this), \"f\");\n    __classPrivateFieldSet(this, _Stickers_resizeHandler, this.onResize.bind(this), \"f\");\n    this.scrollContainer.addEventListener('scroll', __classPrivateFieldGet(this, _Stickers_scrollHandler, \"f\"));\n    window.addEventListener('resize', __classPrivateFieldGet(this, _Stickers_resizeHandler, \"f\"));\n    // Not sure we need this. Maybe when DOM was persisted...\n    window.addEventListener('beforeunload', onBeforeunload);\n  }\n  rmHandlers() {\n    this.scrollContainer.removeEventListener('scroll', __classPrivateFieldGet(this, _Stickers_scrollHandler, \"f\"));\n    window.removeEventListener('resize', __classPrivateFieldGet(this, _Stickers_resizeHandler, \"f\"));\n    window.removeEventListener('beforeunload', onBeforeunload);\n  }\n  snapshotItemRects() {\n    __classPrivateFieldGet(this, _Stickers_stickers, \"f\").forEach(sticker => {\n      const rect = sticker.element.getBoundingClientRect();\n      sticker.top = rect.top;\n      sticker.bottom = rect.bottom;\n      sticker.height = rect.height;\n    });\n  }\n  onScroll() {\n    clearTimeout(__classPrivateFieldGet(this, _Stickers_scrollEndTimeout, \"f\"));\n    const currentScrollY = this.getScrollY();\n    __classPrivateFieldSet(this, _Stickers_priorScrollY, !Number.isNaN(__classPrivateFieldGet(this, _Stickers_priorScrollY, \"f\")) ? __classPrivateFieldGet(this, _Stickers_priorScrollY, \"f\") : __classPrivateFieldGet(this, _Stickers_scrollIntervalStart, \"f\"), \"f\");\n    // Diff between priorScrollY and new currentScrollY to determine direction\n    __classPrivateFieldSet(this, _Stickers_scrollDirection, currentScrollY - __classPrivateFieldGet(this, _Stickers_priorScrollY, \"f\") > 0 ? 1 : -1, \"f\");\n    // How much scroll changed + or - within the debounce interval\n    __classPrivateFieldSet(this, _Stickers_scrollIntervalChange, currentScrollY - __classPrivateFieldGet(this, _Stickers_scrollIntervalStart, \"f\"), \"f\");\n    // Update old to new for next scroll event\n    __classPrivateFieldSet(this, _Stickers_priorScrollY, currentScrollY, \"f\");\n    // When scrolling has stopped\n    __classPrivateFieldSet(this, _Stickers_scrollEndTimeout, window.setTimeout(() => {\n      // Reset for next scroll starting point\n      __classPrivateFieldSet(this, _Stickers_scrollIntervalStart, __classPrivateFieldGet(this, _Stickers_priorScrollY, \"f\"), \"f\");\n      // Reset until next scroll\n      __classPrivateFieldSet(this, _Stickers_vpHeightSnapshot, NaN, \"f\");\n      __classPrivateFieldSet(this, _Stickers_sfHeightSnapshot, NaN, \"f\");\n      __classPrivateFieldSet(this, _Stickers_isScrolling, false, \"f\");\n    }, __classPrivateFieldGet(this, _Stickers_scrollDebounce, \"f\")), \"f\");\n    // Additional scroll calls always have to test for stick state change\n    if (__classPrivateFieldGet(this, _Stickers_isScrolling, \"f\")) {\n      this.testForStick();\n      return;\n    }\n    // Only reaches here on first call and we note as in a scrolling state\n    __classPrivateFieldSet(this, _Stickers_isScrolling, true, \"f\");\n    // grab the current rect points for stickers to test against while scrolling\n    this.snapshotItemRects();\n    /**\n     * Get once and cache until scroll settles\n     * Unlikely to change and avoids additional reflows on scroll\n     */\n    __classPrivateFieldSet(this, _Stickers_vpHeightSnapshot, this.getViewportHeight(), \"f\");\n    __classPrivateFieldSet(this, _Stickers_sfHeightSnapshot, this.getScrollFrameHeight(), \"f\");\n    this.testForStick();\n  }\n  onResize() {\n    clearTimeout(__classPrivateFieldGet(this, _Stickers_resizeTimeout, \"f\"));\n    __classPrivateFieldSet(this, _Stickers_resizeTimeout, window.setTimeout(() => {\n      this.snapshotItemRects();\n      __classPrivateFieldGet(this, _Stickers_stickers, \"f\").forEach(sticker => {\n        if (sticker.isStuck) this.addStick(sticker);\n      });\n    }, __classPrivateFieldGet(this, _Stickers_resizeDebounce, \"f\")), \"f\");\n  }\n  getScrollY() {\n    return __classPrivateFieldGet(this, _Stickers_isWindowScroll, \"f\") ? this.scrollContainer.scrollY : this.scrollContainer.scrollTop;\n  }\n  getViewportHeight() {\n    // If we have a height snapshot use it since this has likely been called on scroll\n    if (!Number.isNaN(__classPrivateFieldGet(this, _Stickers_vpHeightSnapshot, \"f\"))) {\n      return __classPrivateFieldGet(this, _Stickers_vpHeightSnapshot, \"f\");\n    }\n    return Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n  }\n  getScrollFrameHeight() {\n    // If we have a height snapshot use it since this has likely been called on scroll\n    if (!Number.isNaN(__classPrivateFieldGet(this, _Stickers_sfHeightSnapshot, \"f\"))) {\n      return __classPrivateFieldGet(this, _Stickers_sfHeightSnapshot, \"f\");\n    }\n    const viewportHeight = this.getViewportHeight();\n    let sfh = viewportHeight;\n    if (!__classPrivateFieldGet(this, _Stickers_isWindowScroll, \"f\")) {\n      sfh = viewportHeight - this.scrollContainer.getBoundingClientRect().top;\n    }\n    return sfh;\n  }\n  testBottomInView(sticker) {\n    const vph = this.getViewportHeight();\n    const sfh = this.getScrollFrameHeight();\n    const sic = __classPrivateFieldGet(this, _Stickers_scrollIntervalChange, \"f\");\n    return sfh + sic + (vph - sfh) >= sticker.bottom + this.offset;\n  }\n  testForStick() {\n    // Don't do anything if scrolling up\n    if (__classPrivateFieldGet(this, _Stickers_scrollDirection, \"f\") === -1) return;\n    __classPrivateFieldGet(this, _Stickers_stickers, \"f\").forEach(sticker => {\n      const bottomIsInView = this.testBottomInView(sticker);\n      const hasHeightChange = !Number.isNaN(sticker.priorStickHeight) && sticker.height !== sticker.priorStickHeight;\n      if (bottomIsInView) {\n        if (!sticker.isStuck || hasHeightChange) {\n          window.requestAnimationFrame(() => this.addStick(sticker));\n        }\n      } else if (sticker.isStuck && hasHeightChange) {\n        const marginTop = this.getScrollY() + sticker.top - this.offset;\n        window.requestAnimationFrame(() => {\n          this.removeStick(sticker);\n          sticker.element.style.marginTop = `${marginTop}px`;\n        });\n      }\n    });\n    return this;\n  }\n  addStick(sticker) {\n    sticker.element.style.position = 'sticky';\n    sticker.element.style.marginTop = '';\n    sticker.element.style.top = `${this.getStickTop(sticker)}px`;\n    sticker.priorStickHeight = sticker.height;\n    sticker.isStuck = true;\n    return this;\n  }\n  removeStick(sticker) {\n    sticker.element.style.position = '';\n    sticker.element.style.marginTop = '';\n    sticker.element.style.top = '';\n    sticker.isStuck = false;\n    return this;\n  }\n  getStickTop(sticker) {\n    const spHeight = this.getScrollFrameHeight();\n    let offset = this.offset;\n    if (sticker.height + this.offset > spHeight) {\n      offset = spHeight - sticker.height - offset;\n    }\n    return offset;\n  }\n  cleanup() {\n    this.rmHandlers();\n    __classPrivateFieldGet(this, _Stickers_stickers, \"f\").forEach(this.removeStick);\n  }\n}\n_Stickers_scrollDebounce = new WeakMap(), _Stickers_resizeDebounce = new WeakMap(), _Stickers_isWindowScroll = new WeakMap(), _Stickers_scrollIntervalStart = new WeakMap(), _Stickers_scrollIntervalChange = new WeakMap(), _Stickers_scrollDirection = new WeakMap(), _Stickers_priorScrollY = new WeakMap(), _Stickers_resizeTimeout = new WeakMap(), _Stickers_scrollEndTimeout = new WeakMap(), _Stickers_isScrolling = new WeakMap(), _Stickers_vpHeightSnapshot = new WeakMap(), _Stickers_sfHeightSnapshot = new WeakMap(), _Stickers_stickers = new WeakMap(), _Stickers_scrollHandler = new WeakMap(), _Stickers_resizeHandler = new WeakMap();\n/**\n * @example useScrollStick({ elements: [myColumnElements] | '.my-columns', offset: 20 });\n * @param options An object to set the sticky elements, the scroll container and an stuck offset in pixels.\n * @returns void.\n */\nconst useScrollStick = options => {\n  const instance = useRef();\n  useLayoutEffect(() => {\n    if (options?.elements) {\n      instance.current = new Stickers(options);\n    }\n    return () => {\n      instance.current?.cleanup();\n      instance.current = undefined;\n    };\n  }, [options]);\n};\nexport default useScrollStick;","map":{"version":3,"names":["useRef","useLayoutEffect","onBeforeunload","window","scrollTo","Stickers","constructor","_ref","elements","scrollContainer","offset","Object","defineProperty","_Stickers_scrollDebounce","set","_Stickers_resizeDebounce","_Stickers_isWindowScroll","_Stickers_scrollIntervalStart","_Stickers_scrollIntervalChange","_Stickers_scrollDirection","_Stickers_priorScrollY","_Stickers_resizeTimeout","_Stickers_scrollEndTimeout","_Stickers_isScrolling","_Stickers_vpHeightSnapshot","_Stickers_sfHeightSnapshot","_Stickers_stickers","_Stickers_scrollHandler","_Stickers_resizeHandler","__classPrivateFieldSet","NaN","getScrollY","setStickers","snapshotItemRects","addHandlers","Array","from","document","querySelectorAll","map","element","isStuck","top","bottom","height","priorStickHeight","__classPrivateFieldGet","rmHandlers","onScroll","bind","onResize","addEventListener","removeEventListener","forEach","sticker","rect","getBoundingClientRect","clearTimeout","currentScrollY","Number","isNaN","setTimeout","testForStick","getViewportHeight","getScrollFrameHeight","addStick","scrollY","scrollTop","Math","max","documentElement","clientHeight","innerHeight","viewportHeight","sfh","testBottomInView","vph","sic","bottomIsInView","hasHeightChange","requestAnimationFrame","marginTop","removeStick","style","position","getStickTop","spHeight","cleanup","useScrollStick","options","instance","current","undefined"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/@pega/cosmos-react-core/src/hooks/useScrollStick.ts"],"sourcesContent":["import { useRef, useLayoutEffect } from 'react';\n\nexport interface ScrollStickOptions {\n  elements: string | HTMLElement[];\n  scrollContainer?: Stickers['scrollContainer'];\n  offset?: number;\n}\n\ninterface Sticker {\n  element: HTMLElement;\n  top: number;\n  bottom: number;\n  height: number;\n  isStuck: boolean;\n  priorStickHeight: number;\n}\n\ntype ElementsOption = string | HTMLElement[];\n\nconst onBeforeunload = () => {\n  window.scrollTo(0, 0);\n};\n\nclass Stickers {\n  scrollContainer: HTMLElement | Window;\n  offset: number;\n  #scrollDebounce: number;\n  #resizeDebounce: number;\n  #isWindowScroll: boolean;\n  #scrollIntervalStart: number;\n  #scrollIntervalChange: number;\n  #scrollDirection: number;\n  #priorScrollY: number;\n  #resizeTimeout: number;\n  #scrollEndTimeout: number;\n  #isScrolling: boolean;\n  #vpHeightSnapshot: number;\n  #sfHeightSnapshot: number;\n  #stickers: Sticker[];\n  #scrollHandler: () => void;\n  #resizeHandler: () => void;\n\n  constructor({ elements, scrollContainer = window, offset = 0 }: ScrollStickOptions) {\n    this.scrollContainer = scrollContainer;\n    this.offset = offset;\n\n    this.#scrollDebounce = 100;\n    this.#resizeDebounce = 300;\n    this.#resizeTimeout = NaN;\n    this.#scrollEndTimeout = NaN;\n    this.#priorScrollY = NaN;\n    this.#isScrolling = false;\n    this.#vpHeightSnapshot = NaN;\n    this.#sfHeightSnapshot = NaN;\n    this.#scrollHandler = () => {};\n    this.#resizeHandler = () => {};\n\n    this.#isWindowScroll = this.scrollContainer === window;\n\n    // Only gets reset after scroll stop timeout fires\n    this.#scrollIntervalStart = this.getScrollY();\n\n    // Used to determine scroll change within debounced scroll handler\n    this.#scrollIntervalChange = 0;\n\n    // Used to determine scroll direction by +1(page down) -1(page up)\n    this.#scrollDirection = 0;\n\n    this.#stickers = this.setStickers(elements);\n    this.snapshotItemRects();\n    this.addHandlers();\n  }\n\n  setStickers(elements: ElementsOption) {\n    this.#stickers = (\n      typeof elements === 'string'\n        ? Array.from(document.querySelectorAll<HTMLElement>(elements))\n        : elements\n    ).map(element => ({\n      element,\n      isStuck: false,\n      top: NaN,\n      bottom: NaN,\n      height: NaN,\n      priorStickHeight: NaN\n    }));\n\n    return this.#stickers;\n  }\n\n  addHandlers() {\n    this.rmHandlers();\n    this.#scrollHandler = this.onScroll.bind(this);\n    this.#resizeHandler = this.onResize.bind(this);\n    this.scrollContainer.addEventListener('scroll', this.#scrollHandler);\n    window.addEventListener('resize', this.#resizeHandler);\n    // Not sure we need this. Maybe when DOM was persisted...\n    window.addEventListener('beforeunload', onBeforeunload);\n  }\n\n  rmHandlers() {\n    this.scrollContainer.removeEventListener('scroll', this.#scrollHandler);\n    window.removeEventListener('resize', this.#resizeHandler);\n    window.removeEventListener('beforeunload', onBeforeunload);\n  }\n\n  snapshotItemRects() {\n    this.#stickers.forEach(sticker => {\n      const rect = sticker.element.getBoundingClientRect();\n      sticker.top = rect.top;\n      sticker.bottom = rect.bottom;\n      sticker.height = rect.height;\n    });\n  }\n\n  onScroll() {\n    clearTimeout(this.#scrollEndTimeout);\n\n    const currentScrollY = this.getScrollY();\n\n    this.#priorScrollY = !Number.isNaN(this.#priorScrollY)\n      ? this.#priorScrollY\n      : this.#scrollIntervalStart;\n\n    // Diff between priorScrollY and new currentScrollY to determine direction\n    this.#scrollDirection = currentScrollY - this.#priorScrollY > 0 ? 1 : -1;\n\n    // How much scroll changed + or - within the debounce interval\n    this.#scrollIntervalChange = currentScrollY - this.#scrollIntervalStart;\n\n    // Update old to new for next scroll event\n    this.#priorScrollY = currentScrollY;\n\n    // When scrolling has stopped\n    this.#scrollEndTimeout = window.setTimeout(() => {\n      // Reset for next scroll starting point\n      this.#scrollIntervalStart = this.#priorScrollY;\n\n      // Reset until next scroll\n      this.#vpHeightSnapshot = NaN;\n      this.#sfHeightSnapshot = NaN;\n\n      this.#isScrolling = false;\n    }, this.#scrollDebounce);\n\n    // Additional scroll calls always have to test for stick state change\n    if (this.#isScrolling) {\n      this.testForStick();\n      return;\n    }\n\n    // Only reaches here on first call and we note as in a scrolling state\n    this.#isScrolling = true;\n\n    // grab the current rect points for stickers to test against while scrolling\n    this.snapshotItemRects();\n\n    /**\n     * Get once and cache until scroll settles\n     * Unlikely to change and avoids additional reflows on scroll\n     */\n    this.#vpHeightSnapshot = this.getViewportHeight();\n    this.#sfHeightSnapshot = this.getScrollFrameHeight();\n\n    this.testForStick();\n  }\n\n  onResize() {\n    clearTimeout(this.#resizeTimeout);\n    this.#resizeTimeout = window.setTimeout(() => {\n      this.snapshotItemRects();\n      this.#stickers.forEach(sticker => {\n        if (sticker.isStuck) this.addStick(sticker);\n      });\n    }, this.#resizeDebounce);\n  }\n\n  getScrollY() {\n    return this.#isWindowScroll\n      ? (this.scrollContainer as Window).scrollY\n      : (this.scrollContainer as HTMLElement).scrollTop;\n  }\n\n  getViewportHeight() {\n    // If we have a height snapshot use it since this has likely been called on scroll\n    if (!Number.isNaN(this.#vpHeightSnapshot)) {\n      return this.#vpHeightSnapshot;\n    }\n\n    return Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n  }\n\n  getScrollFrameHeight() {\n    // If we have a height snapshot use it since this has likely been called on scroll\n    if (!Number.isNaN(this.#sfHeightSnapshot)) {\n      return this.#sfHeightSnapshot;\n    }\n\n    const viewportHeight = this.getViewportHeight();\n    let sfh = viewportHeight;\n\n    if (!this.#isWindowScroll) {\n      sfh = viewportHeight - (this.scrollContainer as HTMLElement).getBoundingClientRect().top;\n    }\n\n    return sfh;\n  }\n\n  testBottomInView(sticker: Sticker) {\n    const vph = this.getViewportHeight();\n    const sfh = this.getScrollFrameHeight();\n    const sic = this.#scrollIntervalChange;\n\n    return sfh + sic + (vph - sfh) >= sticker.bottom + this.offset;\n  }\n\n  testForStick() {\n    // Don't do anything if scrolling up\n    if (this.#scrollDirection === -1) return;\n\n    this.#stickers.forEach(sticker => {\n      const bottomIsInView = this.testBottomInView(sticker);\n      const hasHeightChange =\n        !Number.isNaN(sticker.priorStickHeight) && sticker.height !== sticker.priorStickHeight;\n\n      if (bottomIsInView) {\n        if (!sticker.isStuck || hasHeightChange) {\n          window.requestAnimationFrame(() => this.addStick(sticker));\n        }\n      } else if (sticker.isStuck && hasHeightChange) {\n        const marginTop = this.getScrollY() + sticker.top - this.offset;\n\n        window.requestAnimationFrame(() => {\n          this.removeStick(sticker);\n          sticker.element.style.marginTop = `${marginTop}px`;\n        });\n      }\n    });\n\n    return this;\n  }\n\n  addStick(sticker: Sticker) {\n    sticker.element.style.position = 'sticky';\n    sticker.element.style.marginTop = '';\n    sticker.element.style.top = `${this.getStickTop(sticker)}px`;\n    sticker.priorStickHeight = sticker.height;\n    sticker.isStuck = true;\n    return this;\n  }\n\n  removeStick(sticker: Sticker) {\n    sticker.element.style.position = '';\n    sticker.element.style.marginTop = '';\n    sticker.element.style.top = '';\n    sticker.isStuck = false;\n    return this;\n  }\n\n  getStickTop(sticker: Sticker) {\n    const spHeight = this.getScrollFrameHeight();\n    let offset = this.offset;\n\n    if (sticker.height + this.offset > spHeight) {\n      offset = spHeight - sticker.height - offset;\n    }\n\n    return offset;\n  }\n\n  cleanup() {\n    this.rmHandlers();\n    this.#stickers.forEach(this.removeStick);\n  }\n}\n\n/**\n * @example useScrollStick({ elements: [myColumnElements] | '.my-columns', offset: 20 });\n * @param options An object to set the sticky elements, the scroll container and an stuck offset in pixels.\n * @returns void.\n */\nconst useScrollStick = (options?: ScrollStickOptions): void => {\n  const instance = useRef<Stickers>();\n\n  useLayoutEffect(() => {\n    if (options?.elements) {\n      instance.current = new Stickers(options);\n    }\n\n    return () => {\n      instance.current?.cleanup();\n      instance.current = undefined;\n    };\n  }, [options]);\n};\n\nexport default useScrollStick;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}