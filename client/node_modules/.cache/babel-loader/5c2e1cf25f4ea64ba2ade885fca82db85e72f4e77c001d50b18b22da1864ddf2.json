{"ast":null,"code":"/* IMPORT */\nimport { RESULT } from './constants.js';\nimport Shortcut from './shortcut.js';\nimport Utils from './utils.js';\n/* MAIN */\nclass Listener {\n  /* CONSTRUCTOR */\n  constructor(options) {\n    this.lastKeydownID = -1;\n    this.currentKeydownShortcutID = [];\n    this.currentKeypressShortcutID = [];\n    this.currentKeyupShortcutID = [];\n    this.resetNextKeydownShortcutID = false;\n    this.triggeredNextKeypress = true;\n    this.ignoreNextKeypress = false;\n    this.listening = false;\n    /* API */\n    this.on = () => {\n      if (this.listening) return;\n      this.listening = true;\n      this.target.addEventListener('keydown', this.handler, {\n        capture: this.capture\n      });\n      this.target.addEventListener('keypress', this.handler, {\n        capture: this.capture\n      });\n      this.target.addEventListener('keyup', this.handler, {\n        capture: this.capture\n      });\n    };\n    this.off = () => {\n      if (!this.listening) return;\n      this.listening = false;\n      this.target.removeEventListener('keydown', this.handler, {\n        capture: this.capture\n      });\n      this.target.removeEventListener('keypress', this.handler, {\n        capture: this.capture\n      });\n      this.target.removeEventListener('keyup', this.handler, {\n        capture: this.capture\n      });\n    };\n    this.isListening = () => {\n      return this.listening;\n    };\n    this.handler = event => {\n      if (!Utils.isKeyboardEvent(event)) return;\n      if (!this.shouldHandleEvent(event)) return;\n      const {\n        type\n      } = event;\n      const isKeydown = type === 'keydown';\n      const isKeypress = type === 'keypress';\n      const isKeyup = type === 'keyup';\n      if (isKeydown) {\n        // Resetting, in case two keydown events get triggered in a row\n        this.ignoreNextKeypress = false;\n      }\n      if (isKeypress && this.ignoreNextKeypress) {\n        // Ignoring this keypress, already handled on keydown\n        this.triggeredNextKeypress = true;\n        return;\n      }\n      const id = Shortcut.event2id(event);\n      const triggerKey = Shortcut.getTriggerKey(id);\n      if (isKeydown) {\n        this.lastKeydownID = id;\n      }\n      if (isKeyup && (triggerKey || id !== this.lastKeydownID)) {\n        // Keyup only handles no-trigger events, if no other shortcuts with triggers have been triggered before, if no other keys havve been registered on keyPress\n        this.currentKeyupShortcutID.length = 0;\n        return;\n      }\n      if (!isKeyup && !triggerKey) return; // Only keyup handles non-trigger events\n      const shortcutID = isKeydown ? this.currentKeydownShortcutID : isKeyup ? this.currentKeyupShortcutID : this.currentKeypressShortcutID;\n      if (isKeydown && !this.resetNextKeydownShortcutID && !this.triggeredNextKeypress) {\n        // A chord triggered on keydown didn't get triggered on keypress also, so we copy it over manually\n        this.currentKeypressShortcutID.push(this.currentKeydownShortcutID[this.currentKeydownShortcutID.length - 1]);\n      }\n      if (isKeydown && this.resetNextKeydownShortcutID) {\n        // Resetting keydown shortcut id\n        shortcutID.length = 0;\n        this.resetNextKeydownShortcutID = false;\n      }\n      shortcutID.push(id);\n      if (isKeypress && Utils.isEqual(this.currentKeydownShortcutID, shortcutID)) {\n        // Avoiding handling keypress for the same detected shortcut in order to maximize performance. Unless the handler for this shortcut has been added between keydown and keypress (weird) this won't be a problem\n        if (this.resetNextKeydownShortcutID) {\n          this.currentKeypressShortcutID.length = 0;\n        }\n        this.triggeredNextKeypress = true;\n        return;\n      }\n      const result = this.options.handler(shortcutID, event);\n      if (result === RESULT.HANDLED) {\n        // Resetting all shortcuts\n        this.resetNextKeydownShortcutID = true;\n        this.currentKeypressShortcutID.length = 0;\n        this.currentKeyupShortcutID.length = 0;\n      } else if (result === RESULT.UNHANDLEABLE) {\n        // Resetting only the current shortcut\n        if (isKeydown) {\n          this.resetNextKeydownShortcutID = true;\n        } else if (isKeypress) {\n          this.currentKeypressShortcutID.length = 0;\n        } else if (isKeyup) {\n          this.currentKeyupShortcutID.length = 0;\n        }\n      } else if (typeof result === 'object') {\n        // Changing the current shortcut\n        shortcutID.splice(0, Infinity, ...result);\n      }\n      if (!isKeyup) {\n        this.ignoreNextKeypress = isKeydown && result === RESULT.HANDLED;\n        this.triggeredNextKeypress = isKeypress;\n      }\n    };\n    this.options = options;\n    this.capture = !!options.capture;\n    this.target = options.target || document;\n    this.shouldHandleEvent = options.shouldHandleEvent || (event => !event.defaultPrevented);\n  }\n}\n/* EXPORT */\nexport default Listener;","map":{"version":3,"names":["RESULT","Shortcut","Utils","Listener","constructor","options","lastKeydownID","currentKeydownShortcutID","currentKeypressShortcutID","currentKeyupShortcutID","resetNextKeydownShortcutID","triggeredNextKeypress","ignoreNextKeypress","listening","on","target","addEventListener","handler","capture","off","removeEventListener","isListening","event","isKeyboardEvent","shouldHandleEvent","type","isKeydown","isKeypress","isKeyup","id","event2id","triggerKey","getTriggerKey","length","shortcutID","push","isEqual","result","HANDLED","UNHANDLEABLE","splice","Infinity","document","defaultPrevented"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/shortcuts/dist/listener.js"],"sourcesContent":["/* IMPORT */\nimport { RESULT } from './constants.js';\nimport Shortcut from './shortcut.js';\nimport Utils from './utils.js';\n/* MAIN */\nclass Listener {\n    /* CONSTRUCTOR */\n    constructor(options) {\n        this.lastKeydownID = -1;\n        this.currentKeydownShortcutID = [];\n        this.currentKeypressShortcutID = [];\n        this.currentKeyupShortcutID = [];\n        this.resetNextKeydownShortcutID = false;\n        this.triggeredNextKeypress = true;\n        this.ignoreNextKeypress = false;\n        this.listening = false;\n        /* API */\n        this.on = () => {\n            if (this.listening)\n                return;\n            this.listening = true;\n            this.target.addEventListener('keydown', this.handler, { capture: this.capture });\n            this.target.addEventListener('keypress', this.handler, { capture: this.capture });\n            this.target.addEventListener('keyup', this.handler, { capture: this.capture });\n        };\n        this.off = () => {\n            if (!this.listening)\n                return;\n            this.listening = false;\n            this.target.removeEventListener('keydown', this.handler, { capture: this.capture });\n            this.target.removeEventListener('keypress', this.handler, { capture: this.capture });\n            this.target.removeEventListener('keyup', this.handler, { capture: this.capture });\n        };\n        this.isListening = () => {\n            return this.listening;\n        };\n        this.handler = (event) => {\n            if (!Utils.isKeyboardEvent(event))\n                return;\n            if (!this.shouldHandleEvent(event))\n                return;\n            const { type } = event;\n            const isKeydown = (type === 'keydown');\n            const isKeypress = (type === 'keypress');\n            const isKeyup = (type === 'keyup');\n            if (isKeydown) { // Resetting, in case two keydown events get triggered in a row\n                this.ignoreNextKeypress = false;\n            }\n            if (isKeypress && this.ignoreNextKeypress) { // Ignoring this keypress, already handled on keydown\n                this.triggeredNextKeypress = true;\n                return;\n            }\n            const id = Shortcut.event2id(event);\n            const triggerKey = Shortcut.getTriggerKey(id);\n            if (isKeydown) {\n                this.lastKeydownID = id;\n            }\n            if (isKeyup && (triggerKey || id !== this.lastKeydownID)) { // Keyup only handles no-trigger events, if no other shortcuts with triggers have been triggered before, if no other keys havve been registered on keyPress\n                this.currentKeyupShortcutID.length = 0;\n                return;\n            }\n            if (!isKeyup && !triggerKey)\n                return; // Only keyup handles non-trigger events\n            const shortcutID = isKeydown ? this.currentKeydownShortcutID : (isKeyup ? this.currentKeyupShortcutID : this.currentKeypressShortcutID);\n            if (isKeydown && !this.resetNextKeydownShortcutID && !this.triggeredNextKeypress) { // A chord triggered on keydown didn't get triggered on keypress also, so we copy it over manually\n                this.currentKeypressShortcutID.push(this.currentKeydownShortcutID[this.currentKeydownShortcutID.length - 1]);\n            }\n            if (isKeydown && this.resetNextKeydownShortcutID) { // Resetting keydown shortcut id\n                shortcutID.length = 0;\n                this.resetNextKeydownShortcutID = false;\n            }\n            shortcutID.push(id);\n            if (isKeypress && Utils.isEqual(this.currentKeydownShortcutID, shortcutID)) { // Avoiding handling keypress for the same detected shortcut in order to maximize performance. Unless the handler for this shortcut has been added between keydown and keypress (weird) this won't be a problem\n                if (this.resetNextKeydownShortcutID) {\n                    this.currentKeypressShortcutID.length = 0;\n                }\n                this.triggeredNextKeypress = true;\n                return;\n            }\n            const result = this.options.handler(shortcutID, event);\n            if (result === RESULT.HANDLED) { // Resetting all shortcuts\n                this.resetNextKeydownShortcutID = true;\n                this.currentKeypressShortcutID.length = 0;\n                this.currentKeyupShortcutID.length = 0;\n            }\n            else if (result === RESULT.UNHANDLEABLE) { // Resetting only the current shortcut\n                if (isKeydown) {\n                    this.resetNextKeydownShortcutID = true;\n                }\n                else if (isKeypress) {\n                    this.currentKeypressShortcutID.length = 0;\n                }\n                else if (isKeyup) {\n                    this.currentKeyupShortcutID.length = 0;\n                }\n            }\n            else if (typeof result === 'object') { // Changing the current shortcut\n                shortcutID.splice(0, Infinity, ...result);\n            }\n            if (!isKeyup) {\n                this.ignoreNextKeypress = isKeydown && result === RESULT.HANDLED;\n                this.triggeredNextKeypress = isKeypress;\n            }\n        };\n        this.options = options;\n        this.capture = !!options.capture;\n        this.target = options.target || document;\n        this.shouldHandleEvent = options.shouldHandleEvent || (event => !event.defaultPrevented);\n    }\n}\n/* EXPORT */\nexport default Listener;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}