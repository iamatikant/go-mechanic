{"ast":null,"code":"import creditCardType, { getTypeInfo } from 'credit-card-type';\nconst prettyPrintCard = (value, gaps) => {\n  const offsets = [0].concat(gaps.filter(n => n < value.length), value.length);\n  const groups = [];\n  for (let i = 0; offsets[i] < value.length; i += 1) {\n    groups.push(value.substring(offsets[i], offsets[i + 1]));\n  }\n  return groups.join(' ');\n};\n/**\n * Returns a formatted and obfuscated on demand partial credit card number.\n * @param value starting, partial number.\n * @param formattingOptions additional formatting options\n */\nexport const formatCreditCard = function (value) {\n  let {\n    obfuscation = 'none'\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let result;\n  switch (obfuscation) {\n    case 'none':\n      result = prettyPrintCard(value, creditCardType(value)[0]?.gaps ?? []);\n      break;\n    case 'partial':\n      result = prettyPrintCard(value.slice(-4).padStart(16, '•'), [4, 8, 12]);\n      break;\n    default:\n      result = Array.from({\n        length: 4\n      }).fill('•'.repeat(4)).join(' ');\n  }\n  return result;\n};\n/** Returns maximum total length of formatted credit card of given type including gaps. */\nexport const creditCardTotalLength = cardType => {\n  const type = getTypeInfo(cardType);\n  return Math.max(...type.lengths) + type.gaps.length;\n};\n/** Returns true if given first numbers match a pattern of any card, false otherwise. */\nexport const isPossibleCardNumber = cardNumber => {\n  return creditCardType(cardNumber).length > 0;\n};\n/** Returns true if given card number is valid (matches the pattern and length of a card type), false otherwise. */\nexport const isValidCreditCard = cardNumber => {\n  return creditCardType(cardNumber.toString())[0]?.lengths.includes(cardNumber.toString().length) ?? false;\n};","map":{"version":3,"names":["creditCardType","getTypeInfo","prettyPrintCard","value","gaps","offsets","concat","filter","n","length","groups","i","push","substring","join","formatCreditCard","obfuscation","arguments","undefined","result","slice","padStart","Array","from","fill","repeat","creditCardTotalLength","cardType","type","Math","max","lengths","isPossibleCardNumber","cardNumber","isValidCreditCard","toString","includes"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/@pega/cosmos-react-core/src/components/CreditCard/utils.ts"],"sourcesContent":["import creditCardType, { getTypeInfo } from 'credit-card-type';\n\nimport type { FormattingOptions } from './CreditCard.types';\n\nconst prettyPrintCard = (value: string, gaps: number[]): string => {\n  const offsets = [0].concat(\n    gaps.filter(n => n < value.length),\n    value.length\n  );\n\n  const groups = [];\n  for (let i = 0; offsets[i] < value.length; i += 1) {\n    groups.push(value.substring(offsets[i], offsets[i + 1]));\n  }\n  return groups.join(' ');\n};\n\n/**\n * Returns a formatted and obfuscated on demand partial credit card number.\n * @param value starting, partial number.\n * @param formattingOptions additional formatting options\n */\nexport const formatCreditCard = (\n  value: string,\n  { obfuscation = 'none' }: FormattingOptions = {}\n): string => {\n  let result;\n  switch (obfuscation) {\n    case 'none':\n      result = prettyPrintCard(value, creditCardType(value)[0]?.gaps ?? []);\n      break;\n    case 'partial':\n      result = prettyPrintCard(value.slice(-4).padStart(16, '•'), [4, 8, 12]);\n      break;\n    default:\n      result = Array.from({ length: 4 }).fill('•'.repeat(4)).join(' ');\n  }\n  return result;\n};\n\n/** Returns maximum total length of formatted credit card of given type including gaps. */\nexport const creditCardTotalLength = (cardType: string): number => {\n  const type = getTypeInfo(cardType);\n  return Math.max(...type.lengths) + type.gaps.length;\n};\n\n/** Returns true if given first numbers match a pattern of any card, false otherwise. */\nexport const isPossibleCardNumber = (cardNumber: string): boolean => {\n  return creditCardType(cardNumber).length > 0;\n};\n\n/** Returns true if given card number is valid (matches the pattern and length of a card type), false otherwise. */\nexport const isValidCreditCard = (cardNumber: number): boolean => {\n  return (\n    creditCardType(cardNumber.toString())[0]?.lengths.includes(cardNumber.toString().length) ??\n    false\n  );\n};\n"],"mappings":"AAAA,OAAOA,cAAc,IAAIC,WAAW,QAAQ,kBAAkB;AAI9D,MAAMC,eAAe,GAAGA,CAACC,KAAa,EAAEC,IAAc,KAAY;EAChE,MAAMC,OAAO,GAAG,CAAC,CAAC,CAAC,CAACC,MAAM,CACxBF,IAAI,CAACG,MAAM,CAACC,CAAC,IAAIA,CAAC,GAAGL,KAAK,CAACM,MAAM,CAAC,EAClCN,KAAK,CAACM,MAAM,CACb;EAED,MAAMC,MAAM,GAAG,EAAE;EACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEN,OAAO,CAACM,CAAC,CAAC,GAAGR,KAAK,CAACM,MAAM,EAAEE,CAAC,IAAI,CAAC,EAAE;IACjDD,MAAM,CAACE,IAAI,CAACT,KAAK,CAACU,SAAS,CAACR,OAAO,CAACM,CAAC,CAAC,EAAEN,OAAO,CAACM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;EAE1D,OAAOD,MAAM,CAACI,IAAI,CAAC,GAAG,CAAC;AACzB,CAAC;AAED;;;;;AAKA,OAAO,MAAMC,gBAAgB,GAAG,SAAAA,CAC9BZ,KAAa,EAEH;EAAA,IADV;IAAEa,WAAW,GAAG;EAAM,IAAAC,SAAA,CAAAR,MAAA,QAAAQ,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAwB,EAAE;EAEhD,IAAIE,MAAM;EACV,QAAQH,WAAW;IACjB,KAAK,MAAM;MACTG,MAAM,GAAGjB,eAAe,CAACC,KAAK,EAAEH,cAAc,CAACG,KAAK,CAAC,CAAC,CAAC,CAAC,EAAEC,IAAI,IAAI,EAAE,CAAC;MACrE;IACF,KAAK,SAAS;MACZe,MAAM,GAAGjB,eAAe,CAACC,KAAK,CAACiB,KAAK,CAAC,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;MACvE;IACF;MACEF,MAAM,GAAGG,KAAK,CAACC,IAAI,CAAC;QAAEd,MAAM,EAAE;MAAC,CAAE,CAAC,CAACe,IAAI,CAAC,GAAG,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC,CAACX,IAAI,CAAC,GAAG,CAAC;EAAC;EAErE,OAAOK,MAAM;AACf,CAAC;AAED;AACA,OAAO,MAAMO,qBAAqB,GAAIC,QAAgB,IAAY;EAChE,MAAMC,IAAI,GAAG3B,WAAW,CAAC0B,QAAQ,CAAC;EAClC,OAAOE,IAAI,CAACC,GAAG,CAAC,GAAGF,IAAI,CAACG,OAAO,CAAC,GAAGH,IAAI,CAACxB,IAAI,CAACK,MAAM;AACrD,CAAC;AAED;AACA,OAAO,MAAMuB,oBAAoB,GAAIC,UAAkB,IAAa;EAClE,OAAOjC,cAAc,CAACiC,UAAU,CAAC,CAACxB,MAAM,GAAG,CAAC;AAC9C,CAAC;AAED;AACA,OAAO,MAAMyB,iBAAiB,GAAID,UAAkB,IAAa;EAC/D,OACEjC,cAAc,CAACiC,UAAU,CAACE,QAAQ,EAAE,CAAC,CAAC,CAAC,CAAC,EAAEJ,OAAO,CAACK,QAAQ,CAACH,UAAU,CAACE,QAAQ,EAAE,CAAC1B,MAAM,CAAC,IACxF,KAAK;AAET,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}