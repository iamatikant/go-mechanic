{"ast":null,"code":"import { deepGet, defineSmartGetter } from '../utils';\nexport const resetToInitial = Symbol.for('@pega/cosmos-react-core.theme.resetToInitial');\nclass ThemeMachine {\n  overrideInTree(keys) {\n    let ancestor = this;\n    const fullProp = keys.join('.');\n    while (ancestor) {\n      // Trigger getters in the ancestor themes.\n      deepGet(ancestor.theme, keys);\n      if (ancestor.overrides.has(fullProp)) return !!ancestor.overrides.get(fullProp);\n      ancestor = ancestor.parent;\n    }\n    return false;\n  }\n  constructTheme(theme) {\n    var _this = this;\n    const constructForNode = function () {\n      let keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      const themeNode = {};\n      Object.keys(deepGet(_this.definition, keys)).forEach(key => {\n        // Ignore comment nodes.\n        if (key === '$comment') return;\n        const propKeys = [...keys, key];\n        const defNode = deepGet(_this.definition, propKeys);\n        // If it is not a leaf node of the theme definition...\n        if (defNode.$type === undefined) {\n          // recursively run for child nodes.\n          defineSmartGetter(themeNode, key, () => constructForNode(propKeys));\n          return;\n        }\n        const themeValue = deepGet(theme, propKeys);\n        // If a theme value was set for this ThemeMachine...\n        if (themeValue !== undefined) {\n          // set overrides to true, unless it is being reset.\n          _this.overrides.set(propKeys.join('.'), themeValue !== resetToInitial);\n        }\n        // If a theme value was set for this ThemeMachine, is not being reset, and is for a non-constant property...\n        if (themeValue !== undefined && themeValue !== resetToInitial && !defNode.$constant) {\n          // set to the provided value.\n          themeNode[key] = themeValue;\n        }\n        // If the property has been overridden in the tree (and not reset)...\n        else if (_this.overrideInTree(propKeys)) {\n          // set to the value in the parent theme.\n          defineSmartGetter(themeNode, key, () => deepGet(_this.parent.theme, propKeys));\n        }\n        // If the property type is inherited...\n        else if (defNode.$type === 'inherited') {\n          // set to the value of the inherited property in this theme.\n          defineSmartGetter(themeNode, key, () => deepGet(_this.theme, defNode.$value.split('.')));\n        }\n        // If the property type is literal...\n        else if (defNode.$type === 'literal') {\n          // set to the value listed in the definition.\n          themeNode[key] = defNode.$value;\n        }\n      });\n      return themeNode;\n    };\n    return constructForNode();\n  }\n  constructor(_ref) {\n    let {\n      theme = {},\n      parent,\n      definition\n    } = _ref;\n    Object.defineProperty(this, \"parent\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"definition\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"overrides\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"theme\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.parent = parent ?? null;\n    this.definition = parent ? parent.definition : definition;\n    this.overrides = new Map();\n    this.theme = this.constructTheme(theme);\n  }\n}\nexport default ThemeMachine;","map":{"version":3,"names":["deepGet","defineSmartGetter","resetToInitial","Symbol","for","ThemeMachine","overrideInTree","keys","ancestor","fullProp","join","theme","overrides","has","get","parent","constructTheme","_this","constructForNode","arguments","length","undefined","themeNode","Object","definition","forEach","key","propKeys","defNode","$type","themeValue","set","$constant","$value","split","constructor","_ref","defineProperty","Map"],"sources":["/Users/dasp10/Documents/KT_project/go-mechanic/client/node_modules/@pega/cosmos-react-core/src/theme/ThemeMachine.ts"],"sourcesContent":["import { deepGet, defineSmartGetter } from '../utils';\nimport { DeepPartial } from '../types';\n\nexport interface ThemeLeaf<Value> {\n  $type: string;\n  $value: Value;\n  $constant?: boolean;\n  $comment?: string;\n}\n\nexport type ThemeDefinition = {\n  [key: string]: ThemeLeaf<unknown> | ThemeDefinition;\n};\n\nexport type ToThemeIFace<Node, Extension = never> = Node extends ThemeLeaf<infer LeafVal>\n  ? (LeafVal extends null ? LeafVal | string : LeafVal) | Extension\n  : Node extends object\n  ? {\n      readonly [Key in Exclude<keyof Node, '$comment'>]: ToThemeIFace<Node[Key], Extension>;\n    }\n  : Node | Extension;\n\nexport type SettableTheme<Def extends ThemeDefinition> = DeepPartial<ToThemeIFace<Def, symbol>>;\n\nexport const resetToInitial = Symbol.for('@pega/cosmos-react-core.theme.resetToInitial');\n\nexport interface ThemeMachineLike<Definition extends ThemeDefinition> {\n  parent: ThemeMachineLike<Definition> | null;\n\n  definition: Definition;\n\n  overrides: Map<string, boolean>;\n\n  readonly theme: ToThemeIFace<Definition>;\n}\n\nclass ThemeMachine<Definition extends ThemeDefinition> implements ThemeMachineLike<Definition> {\n  parent: ThemeMachineLike<Definition> | null;\n\n  definition: Definition;\n\n  overrides: Map<string, boolean>;\n\n  readonly theme: ToThemeIFace<Definition>;\n\n  overrideInTree(keys: string[]): boolean {\n    let ancestor: ThemeMachineLike<Definition> | null = this;\n    const fullProp = keys.join('.');\n\n    while (ancestor) {\n      // Trigger getters in the ancestor themes.\n      deepGet(ancestor.theme, keys);\n\n      if (ancestor.overrides.has(fullProp)) return !!ancestor.overrides.get(fullProp);\n      ancestor = ancestor.parent;\n    }\n\n    return false;\n  }\n\n  constructTheme(theme: SettableTheme<Definition>): ToThemeIFace<Definition> {\n    const constructForNode = (keys: string[] = []) => {\n      const themeNode: Record<string, any> = {};\n\n      Object.keys(deepGet(this.definition, keys)).forEach(key => {\n        // Ignore comment nodes.\n        if (key === '$comment') return;\n\n        const propKeys = [...keys, key];\n        const defNode: Record<string, any> = deepGet(this.definition, propKeys);\n\n        // If it is not a leaf node of the theme definition...\n        if (defNode.$type === undefined) {\n          // recursively run for child nodes.\n          defineSmartGetter(themeNode, key, () => constructForNode(propKeys));\n          return;\n        }\n\n        const themeValue = deepGet(theme, propKeys);\n\n        // If a theme value was set for this ThemeMachine...\n        if (themeValue !== undefined) {\n          // set overrides to true, unless it is being reset.\n          this.overrides.set(propKeys.join('.'), themeValue !== resetToInitial);\n        }\n\n        // If a theme value was set for this ThemeMachine, is not being reset, and is for a non-constant property...\n        if (themeValue !== undefined && themeValue !== resetToInitial && !defNode.$constant) {\n          // set to the provided value.\n          themeNode[key] = themeValue;\n        }\n\n        // If the property has been overridden in the tree (and not reset)...\n        else if (this.overrideInTree(propKeys)) {\n          // set to the value in the parent theme.\n          defineSmartGetter(themeNode, key, () => deepGet(this.parent!.theme, propKeys));\n        }\n\n        // If the property type is inherited...\n        else if (defNode.$type === 'inherited') {\n          // set to the value of the inherited property in this theme.\n          defineSmartGetter(themeNode, key, () => deepGet(this.theme, defNode.$value.split('.')));\n        }\n\n        // If the property type is literal...\n        else if (defNode.$type === 'literal') {\n          // set to the value listed in the definition.\n          themeNode[key] = defNode.$value;\n        }\n      });\n\n      return themeNode;\n    };\n\n    return constructForNode() as ToThemeIFace<Definition>;\n  }\n\n  constructor({\n    theme = {} as SettableTheme<Definition>,\n    parent,\n    definition\n  }:\n    | {\n        theme?: SettableTheme<Definition>;\n        parent: ThemeMachineLike<Definition>;\n        definition?: never;\n      }\n    | { theme?: SettableTheme<Definition>; parent?: never; definition: Definition }) {\n    this.parent = parent ?? null;\n    this.definition = parent ? parent.definition : definition;\n    this.overrides = new Map();\n    this.theme = this.constructTheme(theme);\n  }\n}\n\nexport default ThemeMachine;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}