import { ElementType, MouseEvent } from 'react';
export interface BaseProps {
    /** Additional CSS classes. */
    className?: string;
}
export type TestIdsRecord<Elements extends readonly string[] | undefined> = {
    root: string;
} & {
    [Key in NonNullable<Elements>[number] as KebabToCamel<Key>]: string;
};
export interface TestIdProp<Elements extends readonly string[] | undefined = undefined> {
    /**
     * Applies a data-testid attribute to a component's root element and may be utilized as a prefix for descendant elements.
     * Descendant element data-testid attributes are applied in a component to component specific manner.
     */
    testId?: Elements extends undefined ? string : string | Partial<TestIdsRecord<Elements>>;
}
export interface ForwardProps {
    [prop: string]: unknown;
}
export interface NoChildrenProp {
    children?: never;
}
export type HTMLTag = keyof JSX.IntrinsicElements;
export interface AsProp {
    /** HTML tag or React Component to render the component as. */
    as?: ElementType;
    /** HTML tag or React Component to finally render the component as. */
    forwardedAs?: ElementType;
}
export interface Action extends ForwardProps {
    /** A string to uniquely identify this Action within the onClick handler. */
    id: string;
    /** The text content of the Action. */
    text: string;
    /** The name of the Cosmos Icon to render, if any. */
    icon?: string;
    /** A location to navigate to. Passing an href will render a Link styled as a Button. */
    href?: string;
    /** Called when the Action is clicked. */
    onClick?: (id: string, e: MouseEvent<HTMLButtonElement | HTMLAnchorElement | HTMLInputElement>, 
    /**
     * If the action was rendered as an item in a menu the associated menuButton element will be provided.
     * Often necessary for focus purposes.
     */
    menuButton?: HTMLButtonElement) => void;
    /** Determines if the Action will be disabled. */
    disabled?: boolean;
}
export type OmitStrict<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type PartialByKey<T extends object, K extends keyof T> = OmitStrict<T, K> & Partial<Pick<T, K>>;
export type RequiredByKey<T extends object, K extends keyof T> = OmitStrict<T, K> & Required<Pick<T, K>>;
export type DeepPartial<T> = T extends (infer U)[] ? DeepPartial<U>[] : T extends object ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : T;
export type DeepRequired<T> = T extends (infer U)[] ? DeepRequired<U>[] : T extends Function ? T : T extends object ? {
    [K in keyof T]-?: DeepRequired<T[K]>;
} : T;
export type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};
export type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> & {
    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;
}[Keys];
export type DeferInfer<T> = T & {
    [K in keyof T]: T[K];
};
export type PropsWithDefaults<Props extends object = {}, Defaults extends keyof Props = never> = OmitStrict<Props, Defaults> & Required<Pick<Props, Defaults>>;
export type KebabToPascal<S extends string> = S extends `${infer T}-${infer U}` ? `${Capitalize<T>}${KebabToPascal<U>}` : Capitalize<S>;
export type KebabToCamel<S extends string> = string extends S ? string : S extends `-${infer T}` ? KebabToCamel<T> : S extends `${infer T}-${infer U}` ? `${T}${KebabToPascal<U>}` : S;
export type PrettyPrint<T> = T extends object ? {
    [K in keyof T]: T[K];
} : T;
//# sourceMappingURL=types.d.ts.map