import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useRef, forwardRef, useCallback, useReducer, useImperativeHandle } from 'react';
import styled, { css } from 'styled-components';
import { useConsolidatedRef, useFocusWithin, useI18n } from '../../../hooks';
import { defaultThemeProp } from '../../../theme';
import Flex from '../../Flex';
import FormField, { StyledFormField } from '../../FormField/FormField';
import DateRangePicker from '../Picker/DateRangePicker';
import { StyledRangeInputContainer } from '../../Input/Input.styles';
import DateInput from './DateInput';
import { parseToDate } from './utils';
import StyledDateInput from './DateTime.styles';
const StyledDateRangeInput = styled.div(props => {
    const { theme: { components: { input } } } = props;
    return css `
    border: 0;
    min-width: min-content;

    ${StyledFormField} {
      &:last-child > ${StyledDateInput} {
        margin-inline-start: -${input['border-width']};
      }
      & legend {
        align-self: center;
      }
      &:focus,
      &:hover,
      &:focus-within {
        z-index: 2;
      }
    }
  `;
});
StyledDateRangeInput.defaultProps = defaultThemeProp;
const reducer = (prevState, { type, value }) => {
    switch (type) {
        case 'start': {
            return { ...prevState, start: value };
        }
        case 'end': {
            return { ...prevState, end: value };
        }
        default:
            return prevState;
    }
};
const convertToCallbackParameter = (v) => {
    return {
        valueAsISOString: v === undefined || Number.isNaN(v) ? undefined : new Date(v).toISOString(),
        valueAsTimestamp: v
    };
};
const getSelected = (first, second) => {
    const selected = first ?? second;
    return selected ? parseToDate(selected) : undefined;
};
const parseValueToDate = (value) => {
    return value ? parseToDate(value) : undefined;
};
const DateRangeInput = forwardRef(({ value = {}, min, max, label, fromLabel, toLabel, labelHidden, status, required, readOnly, disabled, onChange, onFocus, onBlur, showWeekNumber, autoFocus, fromAdditionalInfo, toAdditionalInfo, handle, ...restProps }, ref) => {
    const t = useI18n();
    const startDateInputRef = useRef(null);
    const endDateInputRef = useRef(null);
    const startDateClearHandle = useRef(null);
    const endDateClearHandle = useRef(null);
    const [state, dispatch] = useReducer(reducer, {
        start: value.start ? parseToDate(value.start).getTime() : undefined,
        end: value.end ? parseToDate(value.end).getTime() : undefined
    });
    // Need to keep the value in ref also, to be able to call onBlur with newest value
    const startDateRef = useRef(convertToCallbackParameter(state.start));
    const endDateRef = useRef(convertToCallbackParameter(state.end));
    useImperativeHandle(handle, () => ({
        clear: () => {
            startDateClearHandle.current?.clear();
            endDateClearHandle.current?.clear();
            const emptyCallbackParameter = convertToCallbackParameter(undefined);
            startDateRef.current = emptyCallbackParameter;
            endDateRef.current = emptyCallbackParameter;
            dispatch({ type: 'start', value: undefined });
            dispatch({ type: 'end', value: undefined });
            onChange({
                start: emptyCallbackParameter,
                end: emptyCallbackParameter
            });
        }
    }), [onChange]);
    const onFocusChange = useCallback((focused) => {
        (focused ? onFocus : onBlur)?.({
            start: startDateRef.current,
            end: endDateRef.current
        });
    }, [onFocus, onBlur]);
    const containerRef = useConsolidatedRef(ref);
    useFocusWithin([containerRef], onFocusChange);
    const onStartDateChange = (selectedDate) => {
        const selected = selectedDate?.getTime();
        let start;
        let end;
        if (state.end && selected && selected > state.end) {
            dispatch({ type: 'start', value: state.end });
            dispatch({ type: 'end', value: selected });
            onChange({
                start: convertToCallbackParameter(state.end),
                end: convertToCallbackParameter(selected)
            });
            start = state.end;
            end = selected;
        }
        else {
            dispatch({ type: 'start', value: selected });
            onChange({
                start: convertToCallbackParameter(selected),
                end: convertToCallbackParameter(state.end)
            });
            start = selected;
            end = state.end;
        }
        startDateRef.current = convertToCallbackParameter(start);
        endDateRef.current = convertToCallbackParameter(end);
        endDateInputRef.current?.setOpen(true);
    };
    const onEndDateChange = (selectedDate) => {
        const selected = selectedDate?.getTime();
        let start;
        let end;
        if (state.start && selected && selected < state.start) {
            dispatch({ type: 'end', value: state.start });
            dispatch({ type: 'start', value: selected });
            onChange({
                start: convertToCallbackParameter(selected),
                end: convertToCallbackParameter(state.start)
            });
            start = selected;
            end = state.start;
        }
        else {
            dispatch({ type: 'end', value: selected });
            onChange({
                start: convertToCallbackParameter(state.start),
                end: convertToCallbackParameter(selected)
            });
            start = state.start;
            end = selected;
        }
        startDateRef.current = convertToCallbackParameter(start);
        endDateRef.current = convertToCallbackParameter(end);
    };
    const getSelectedRange = () => {
        const startDate = parseValueToDate(state.start);
        const endDate = parseValueToDate(state.end);
        if (startDate && endDate && startDate > endDate)
            return undefined;
        return {
            startDate,
            endDate
        };
    };
    const commonProps = {
        required,
        readOnly,
        disabled,
        min,
        max,
        status
    };
    return (_jsx(FormField, { as: StyledDateRangeInput, ...restProps, ref: containerRef, container: { wrap: 'nowrap' }, labelHidden: labelHidden, label: label, labelAs: 'legend', required: required, readOnly: readOnly, status: status, disabled: disabled, children: _jsxs(Flex, { container: true, as: StyledRangeInputContainer, children: [_jsx(DateInput, { ...commonProps, value: state.start, ref: startDateInputRef, handle: startDateClearHandle, picker: {
                        renderer: DateRangePicker,
                        rendererProps: {
                            selected: getSelected(state.start, state.end),
                            selectedRange: getSelectedRange(),
                            onChange: onStartDateChange
                        }
                    }, onBlur: changedValue => {
                        // invalid value stored only in ref, state holds undefined
                        dispatch({
                            type: 'start',
                            value: changedValue.state ? undefined : changedValue.valueAsTimestamp
                        });
                        startDateRef.current = changedValue;
                        onChange({
                            start: changedValue,
                            end: convertToCallbackParameter(state.end)
                        });
                    }, additionalInfo: fromAdditionalInfo, label: fromLabel, "aria-label": `${t('range_from_datetime') + (label ? ` - ${label}` : '')}`, autoFocus: autoFocus }), _jsx(DateInput, { ...commonProps, value: state.end, ref: endDateInputRef, handle: endDateClearHandle, picker: {
                        renderer: DateRangePicker,
                        rendererProps: {
                            selected: getSelected(state.end, state.start),
                            selectedRange: getSelectedRange(),
                            onChange: onEndDateChange
                        }
                    }, onBlur: changedValue => {
                        // invalid value stored only in ref, state holds undefined
                        dispatch({
                            type: 'end',
                            value: changedValue.state ? undefined : changedValue.valueAsTimestamp
                        });
                        endDateRef.current = changedValue;
                        onChange({
                            start: convertToCallbackParameter(state.start),
                            end: changedValue
                        });
                    }, additionalInfo: toAdditionalInfo, label: toLabel, "aria-label": `${t('range_to_datetime') + (label ? ` - ${label}` : '')}` })] }) }));
});
export default DateRangeInput;
//# sourceMappingURL=DateRangeInput.js.map