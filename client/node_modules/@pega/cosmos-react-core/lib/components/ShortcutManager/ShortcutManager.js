import { jsx as _jsx } from "react/jsx-runtime";
import { useEffect, useRef, useMemo, useContext } from 'react';
import { Shortcuts } from 'shortcuts';
import { useAfterInitialEffect } from '../../hooks';
import { windowIsAvailable } from '../../utils';
import { ShortcutManagerContext } from './Context';
const actionRegistry = new Map();
/**
 * Function to register an action triggerable using a shortcut. All actions must be registered before
 * binding a callback.
 * @param actions actions with definitions to be registered.
 */
export const registerAction = (...actions) => {
    actions.forEach(({ id, defaultKeyBinding: defaultShortcut }) => {
        if (!actionRegistry.has(id)) {
            actionRegistry.set(id, { defaultKeyBinding: defaultShortcut });
        }
    });
};
const dispatchShortcutEvent = (actionId, e) => {
    const shortcutEvent = new CustomEvent('shortcut', {
        bubbles: true,
        detail: { actionId }
    });
    e.target?.dispatchEvent(shortcutEvent);
};
const ShortcutManager = ({ children, target, bindings: customBindings = {} }) => {
    const shortcutsRef = useRef();
    const bindings = Object.fromEntries(Array.from(actionRegistry.entries()).map(([action, actionDef]) => [
        action,
        customBindings[action] ?? actionDef.defaultKeyBinding
    ]));
    const context = windowIsAvailable
        ? window.cosmos.shortcutManagerContext ?? ShortcutManagerContext
        : ShortcutManagerContext;
    const priorCtxValue = useContext(context);
    useEffect(() => {
        // bail out if ShortcutManager has been initialized
        if (priorCtxValue.initialized)
            return;
        shortcutsRef.current = new Shortcuts({
            target,
            shouldHandleEvent: e => 
            // both 'keydown' and 'keypress' events are handled by default ('shortcuts' bug?)
            e.type === 'keydown' &&
                !e.defaultPrevented &&
                // don't process event during typing letters/digits into inputs without modifier keys
                !(e.target instanceof HTMLElement &&
                    ['input', 'textarea'].includes(e.target.nodeName.toLowerCase()) &&
                    e.key.match(/a-zA-Z0-9/) &&
                    !['Control', 'Meta'].some(modifier => e.getModifierState(modifier))),
            shortcuts: Object.entries(bindings).map(([action, shortcut]) => ({
                shortcut,
                handler: e => {
                    e.preventDefault();
                    dispatchShortcutEvent(action, e);
                }
            }))
        });
        return () => {
            shortcutsRef.current?.reset();
            shortcutsRef.current = undefined;
        };
    }, [target]);
    useAfterInitialEffect(() => {
        // bail out if ShortcutManager has been initialized
        if (priorCtxValue.initialized)
            return;
        const shortcutInstance = shortcutsRef.current;
        if (shortcutInstance) {
            shortcutInstance.reset();
            shortcutInstance.add(Object.entries(bindings).map(([action, shortcut]) => ({
                shortcut,
                handler: e => dispatchShortcutEvent(action, e)
            })));
        }
    }, [JSON.stringify(bindings)]);
    const ctxValue = useMemo(() => ({
        bindings: Object.freeze(bindings),
        initialized: true
    }), [JSON.stringify(bindings)]);
    if (priorCtxValue.initialized) {
        return _jsx(context.Provider, { value: priorCtxValue, children: children });
    }
    return (_jsx(ShortcutManagerContext.Provider, { value: ctxValue, children: children }));
};
export default ShortcutManager;
//# sourceMappingURL=ShortcutManager.js.map